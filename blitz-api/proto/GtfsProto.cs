// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: gtfs-proto.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace TransitRealtime {

  /// <summary>Holder for reflection information generated from gtfs-proto.proto</summary>
  public static partial class GtfsProtoReflection {

    #region Descriptor
    /// <summary>File descriptor for gtfs-proto.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GtfsProtoReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChBndGZzLXByb3RvLnByb3RvEhB0cmFuc2l0X3JlYWx0aW1lInkKC0ZlZWRN",
            "ZXNzYWdlEiwKBmhlYWRlchgBIAIoCzIcLnRyYW5zaXRfcmVhbHRpbWUuRmVl",
            "ZEhlYWRlchIsCgZlbnRpdHkYAiADKAsyHC50cmFuc2l0X3JlYWx0aW1lLkZl",
            "ZWRFbnRpdHkqBgjoBxDQDyoGCKhGEJBOItcBCgpGZWVkSGVhZGVyEh0KFWd0",
            "ZnNfcmVhbHRpbWVfdmVyc2lvbhgBIAIoCRJRCg5pbmNyZW1lbnRhbGl0eRgC",
            "IAEoDjIrLnRyYW5zaXRfcmVhbHRpbWUuRmVlZEhlYWRlci5JbmNyZW1lbnRh",
            "bGl0eToMRlVMTF9EQVRBU0VUEhEKCXRpbWVzdGFtcBgDIAEoBCI0Cg5JbmNy",
            "ZW1lbnRhbGl0eRIQCgxGVUxMX0RBVEFTRVQQABIQCgxESUZGRVJFTlRJQUwQ",
            "ASoGCOgHENAPKgYIqEYQkE4i+gEKCkZlZWRFbnRpdHkSCgoCaWQYASACKAkS",
            "GQoKaXNfZGVsZXRlZBgCIAEoCDoFZmFsc2USMQoLdHJpcF91cGRhdGUYAyAB",
            "KAsyHC50cmFuc2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUSMgoHdmVoaWNsZRgE",
            "IAEoCzIhLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uEiYKBWFs",
            "ZXJ0GAUgASgLMhcudHJhbnNpdF9yZWFsdGltZS5BbGVydBImCgVzaGFwZRgG",
            "IAEoCzIXLnRyYW5zaXRfcmVhbHRpbWUuU2hhcGUqBgjoBxDQDyoGCKhGEJBO",
            "IusICgpUcmlwVXBkYXRlEi4KBHRyaXAYASACKAsyIC50cmFuc2l0X3JlYWx0",
            "aW1lLlRyaXBEZXNjcmlwdG9yEjQKB3ZlaGljbGUYAyABKAsyIy50cmFuc2l0",
            "X3JlYWx0aW1lLlZlaGljbGVEZXNjcmlwdG9yEkUKEHN0b3BfdGltZV91cGRh",
            "dGUYAiADKAsyKy50cmFuc2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRp",
            "bWVVcGRhdGUSEQoJdGltZXN0YW1wGAQgASgEEg0KBWRlbGF5GAUgASgFEkQK",
            "D3RyaXBfcHJvcGVydGllcxgGIAEoCzIrLnRyYW5zaXRfcmVhbHRpbWUuVHJp",
            "cFVwZGF0ZS5UcmlwUHJvcGVydGllcxpRCg1TdG9wVGltZUV2ZW50Eg0KBWRl",
            "bGF5GAEgASgFEgwKBHRpbWUYAiABKAMSEwoLdW5jZXJ0YWludHkYAyABKAUq",
            "BgjoBxDQDyoGCKhGEJBOGvcECg5TdG9wVGltZVVwZGF0ZRIVCg1zdG9wX3Nl",
            "cXVlbmNlGAEgASgNEg8KB3N0b3BfaWQYBCABKAkSOwoHYXJyaXZhbBgCIAEo",
            "CzIqLnRyYW5zaXRfcmVhbHRpbWUuVHJpcFVwZGF0ZS5TdG9wVGltZUV2ZW50",
            "Ej0KCWRlcGFydHVyZRgDIAEoCzIqLnRyYW5zaXRfcmVhbHRpbWUuVHJpcFVw",
            "ZGF0ZS5TdG9wVGltZUV2ZW50ElUKGmRlcGFydHVyZV9vY2N1cGFuY3lfc3Rh",
            "dHVzGAcgASgOMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24u",
            "T2NjdXBhbmN5U3RhdHVzEmoKFXNjaGVkdWxlX3JlbGF0aW9uc2hpcBgFIAEo",
            "DjJALnRyYW5zaXRfcmVhbHRpbWUuVHJpcFVwZGF0ZS5TdG9wVGltZVVwZGF0",
            "ZS5TY2hlZHVsZVJlbGF0aW9uc2hpcDoJU0NIRURVTEVEElwKFHN0b3BfdGlt",
            "ZV9wcm9wZXJ0aWVzGAYgASgLMj4udHJhbnNpdF9yZWFsdGltZS5UcmlwVXBk",
            "YXRlLlN0b3BUaW1lVXBkYXRlLlN0b3BUaW1lUHJvcGVydGllcxo+ChJTdG9w",
            "VGltZVByb3BlcnRpZXMSGAoQYXNzaWduZWRfc3RvcF9pZBgBIAEoCSoGCOgH",
            "ENAPKgYIqEYQkE4iUAoUU2NoZWR1bGVSZWxhdGlvbnNoaXASDQoJU0NIRURV",
            "TEVEEAASCwoHU0tJUFBFRBABEgsKB05PX0RBVEEQAhIPCgtVTlNDSEVEVUxF",
            "RBADKgYI6AcQ0A8qBgioRhCQThprCg5UcmlwUHJvcGVydGllcxIPCgd0cmlw",
            "X2lkGAEgASgJEhIKCnN0YXJ0X2RhdGUYAiABKAkSEgoKc3RhcnRfdGltZRgD",
            "IAEoCRIQCghzaGFwZV9pZBgEIAEoCSoGCOgHENAPKgYIqEYQkE4qBgjoBxDQ",
            "DyoGCKhGEJBOIt8JCg9WZWhpY2xlUG9zaXRpb24SLgoEdHJpcBgBIAEoCzIg",
            "LnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0b3ISNAoHdmVoaWNsZRgI",
            "IAEoCzIjLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZURlc2NyaXB0b3ISLAoI",
            "cG9zaXRpb24YAiABKAsyGi50cmFuc2l0X3JlYWx0aW1lLlBvc2l0aW9uEh0K",
            "FWN1cnJlbnRfc3RvcF9zZXF1ZW5jZRgDIAEoDRIPCgdzdG9wX2lkGAcgASgJ",
            "EloKDmN1cnJlbnRfc3RhdHVzGAQgASgOMjMudHJhbnNpdF9yZWFsdGltZS5W",
            "ZWhpY2xlUG9zaXRpb24uVmVoaWNsZVN0b3BTdGF0dXM6DUlOX1RSQU5TSVRf",
            "VE8SEQoJdGltZXN0YW1wGAUgASgEEksKEGNvbmdlc3Rpb25fbGV2ZWwYBiAB",
            "KA4yMS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5Db25nZXN0",
            "aW9uTGV2ZWwSSwoQb2NjdXBhbmN5X3N0YXR1cxgJIAEoDjIxLnRyYW5zaXRf",
            "cmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLk9jY3VwYW5jeVN0YXR1cxIcChRv",
            "Y2N1cGFuY3lfcGVyY2VudGFnZRgKIAEoDRJRChZtdWx0aV9jYXJyaWFnZV9k",
            "ZXRhaWxzGAsgAygLMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRp",
            "b24uQ2FycmlhZ2VEZXRhaWxzGtkBCg9DYXJyaWFnZURldGFpbHMSCgoCaWQY",
            "ASABKAkSDQoFbGFiZWwYAiABKAkSXgoQb2NjdXBhbmN5X3N0YXR1cxgDIAEo",
            "DjIxLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLk9jY3VwYW5j",
            "eVN0YXR1czoRTk9fREFUQV9BVkFJTEFCTEUSIAoUb2NjdXBhbmN5X3BlcmNl",
            "bnRhZ2UYBCABKAU6Ai0xEhkKEWNhcnJpYWdlX3NlcXVlbmNlGAUgASgNKgYI",
            "6AcQ0A8qBgioRhCQTiJHChFWZWhpY2xlU3RvcFN0YXR1cxIPCgtJTkNPTUlO",
            "R19BVBAAEg4KClNUT1BQRURfQVQQARIRCg1JTl9UUkFOU0lUX1RPEAIifQoP",
            "Q29uZ2VzdGlvbkxldmVsEhwKGFVOS05PV05fQ09OR0VTVElPTl9MRVZFTBAA",
            "EhQKEFJVTk5JTkdfU01PT1RITFkQARIPCgtTVE9QX0FORF9HTxACEg4KCkNP",
            "TkdFU1RJT04QAxIVChFTRVZFUkVfQ09OR0VTVElPThAEItkBCg9PY2N1cGFu",
            "Y3lTdGF0dXMSCQoFRU1QVFkQABIYChRNQU5ZX1NFQVRTX0FWQUlMQUJMRRAB",
            "EhcKE0ZFV19TRUFUU19BVkFJTEFCTEUQAhIWChJTVEFORElOR19ST09NX09O",
            "TFkQAxIeChpDUlVTSEVEX1NUQU5ESU5HX1JPT01fT05MWRAEEggKBEZVTEwQ",
            "BRIcChhOT1RfQUNDRVBUSU5HX1BBU1NFTkdFUlMQBhIVChFOT19EQVRBX0FW",
            "QUlMQUJMRRAHEhEKDU5PVF9CT0FSREFCTEUQCCoGCOgHENAPKgYIqEYQkE4i",
            "6woKBUFsZXJ0EjIKDWFjdGl2ZV9wZXJpb2QYASADKAsyGy50cmFuc2l0X3Jl",
            "YWx0aW1lLlRpbWVSYW5nZRI5Cg9pbmZvcm1lZF9lbnRpdHkYBSADKAsyIC50",
            "cmFuc2l0X3JlYWx0aW1lLkVudGl0eVNlbGVjdG9yEjsKBWNhdXNlGAYgASgO",
            "Mh0udHJhbnNpdF9yZWFsdGltZS5BbGVydC5DYXVzZToNVU5LTk9XTl9DQVVT",
            "RRI+CgZlZmZlY3QYByABKA4yHi50cmFuc2l0X3JlYWx0aW1lLkFsZXJ0LkVm",
            "ZmVjdDoOVU5LTk9XTl9FRkZFQ1QSLwoDdXJsGAggASgLMiIudHJhbnNpdF9y",
            "ZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjcKC2hlYWRlcl90ZXh0GAogASgL",
            "MiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjwKEGRlc2Ny",
            "aXB0aW9uX3RleHQYCyABKAsyIi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0",
            "ZWRTdHJpbmcSOwoPdHRzX2hlYWRlcl90ZXh0GAwgASgLMiIudHJhbnNpdF9y",
            "ZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEkAKFHR0c19kZXNjcmlwdGlvbl90",
            "ZXh0GA0gASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5n",
            "Ek8KDnNldmVyaXR5X2xldmVsGA4gASgOMiUudHJhbnNpdF9yZWFsdGltZS5B",
            "bGVydC5TZXZlcml0eUxldmVsOhBVTktOT1dOX1NFVkVSSVRZEjAKBWltYWdl",
            "GA8gASgLMiEudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkSW1hZ2USQgoW",
            "aW1hZ2VfYWx0ZXJuYXRpdmVfdGV4dBgQIAEoCzIiLnRyYW5zaXRfcmVhbHRp",
            "bWUuVHJhbnNsYXRlZFN0cmluZxI4CgxjYXVzZV9kZXRhaWwYESABKAsyIi50",
            "cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcSOQoNZWZmZWN0X2Rl",
            "dGFpbBgSIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmlu",
            "ZyLYAQoFQ2F1c2USEQoNVU5LTk9XTl9DQVVTRRABEg8KC09USEVSX0NBVVNF",
            "EAISFQoRVEVDSE5JQ0FMX1BST0JMRU0QAxIKCgZTVFJJS0UQBBIRCg1ERU1P",
            "TlNUUkFUSU9OEAUSDAoIQUNDSURFTlQQBhILCgdIT0xJREFZEAcSCwoHV0VB",
            "VEhFUhAIEg8KC01BSU5URU5BTkNFEAkSEAoMQ09OU1RSVUNUSU9OEAoSEwoP",
            "UE9MSUNFX0FDVElWSVRZEAsSFQoRTUVESUNBTF9FTUVSR0VOQ1kQDCLdAQoG",
            "RWZmZWN0Eg4KCk5PX1NFUlZJQ0UQARITCg9SRURVQ0VEX1NFUlZJQ0UQAhIW",
            "ChJTSUdOSUZJQ0FOVF9ERUxBWVMQAxIKCgZERVRPVVIQBBIWChJBRERJVElP",
            "TkFMX1NFUlZJQ0UQBRIUChBNT0RJRklFRF9TRVJWSUNFEAYSEAoMT1RIRVJf",
            "RUZGRUNUEAcSEgoOVU5LTk9XTl9FRkZFQ1QQCBIOCgpTVE9QX01PVkVEEAkS",
            "DQoJTk9fRUZGRUNUEAoSFwoTQUNDRVNTSUJJTElUWV9JU1NVRRALIkgKDVNl",
            "dmVyaXR5TGV2ZWwSFAoQVU5LTk9XTl9TRVZFUklUWRABEggKBElORk8QAhIL",
            "CgdXQVJOSU5HEAMSCgoGU0VWRVJFEAQqBgjoBxDQDyoGCKhGEJBOIjcKCVRp",
            "bWVSYW5nZRINCgVzdGFydBgBIAEoBBILCgNlbmQYAiABKAQqBgjoBxDQDyoG",
            "CKhGEJBOInEKCFBvc2l0aW9uEhAKCGxhdGl0dWRlGAEgAigCEhEKCWxvbmdp",
            "dHVkZRgCIAIoAhIPCgdiZWFyaW5nGAMgASgCEhAKCG9kb21ldGVyGAQgASgB",
            "Eg0KBXNwZWVkGAUgASgCKgYI6AcQ0A8qBgioRhCQTiLbAgoOVHJpcERlc2Ny",
            "aXB0b3ISDwoHdHJpcF9pZBgBIAEoCRIQCghyb3V0ZV9pZBgFIAEoCRIUCgxk",
            "aXJlY3Rpb25faWQYBiABKA0SEgoKc3RhcnRfdGltZRgCIAEoCRISCgpzdGFy",
            "dF9kYXRlGAMgASgJElQKFXNjaGVkdWxlX3JlbGF0aW9uc2hpcBgEIAEoDjI1",
            "LnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0b3IuU2NoZWR1bGVSZWxh",
            "dGlvbnNoaXAigQEKFFNjaGVkdWxlUmVsYXRpb25zaGlwEg0KCVNDSEVEVUxF",
            "RBAAEgkKBUFEREVEEAESDwoLVU5TQ0hFRFVMRUQQAhIMCghDQU5DRUxFRBAD",
            "EhMKC1JFUExBQ0VNRU5UEAUaAggBEg4KCkRVUExJQ0FURUQQBhILCgdERUxF",
            "VEVEEAcqBgjoBxDQDyoGCKhGEJBOIqMCChFWZWhpY2xlRGVzY3JpcHRvchIK",
            "CgJpZBgBIAEoCRINCgVsYWJlbBgCIAEoCRIVCg1saWNlbnNlX3BsYXRlGAMg",
            "ASgJEmEKFXdoZWVsY2hhaXJfYWNjZXNzaWJsZRgEIAEoDjI4LnRyYW5zaXRf",
            "cmVhbHRpbWUuVmVoaWNsZURlc2NyaXB0b3IuV2hlZWxjaGFpckFjY2Vzc2li",
            "bGU6CE5PX1ZBTFVFImkKFFdoZWVsY2hhaXJBY2Nlc3NpYmxlEgwKCE5PX1ZB",
            "TFVFEAASCwoHVU5LTk9XThABEhkKFVdIRUVMQ0hBSVJfQUNDRVNTSUJMRRAC",
            "EhsKF1dIRUVMQ0hBSVJfSU5BQ0NFU1NJQkxFEAMqBgjoBxDQDyoGCKhGEJBO",
            "IrABCg5FbnRpdHlTZWxlY3RvchIRCglhZ2VuY3lfaWQYASABKAkSEAoIcm91",
            "dGVfaWQYAiABKAkSEgoKcm91dGVfdHlwZRgDIAEoBRIuCgR0cmlwGAQgASgL",
            "MiAudHJhbnNpdF9yZWFsdGltZS5UcmlwRGVzY3JpcHRvchIPCgdzdG9wX2lk",
            "GAUgASgJEhQKDGRpcmVjdGlvbl9pZBgGIAEoDSoGCOgHENAPKgYIqEYQkE4i",
            "pgEKEFRyYW5zbGF0ZWRTdHJpbmcSQwoLdHJhbnNsYXRpb24YASADKAsyLi50",
            "cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcuVHJhbnNsYXRpb24a",
            "PQoLVHJhbnNsYXRpb24SDAoEdGV4dBgBIAIoCRIQCghsYW5ndWFnZRgCIAEo",
            "CSoGCOgHENAPKgYIqEYQkE4qBgjoBxDQDyoGCKhGEJBOIsEBCg9UcmFuc2xh",
            "dGVkSW1hZ2USSQoPbG9jYWxpemVkX2ltYWdlGAEgAygLMjAudHJhbnNpdF9y",
            "ZWFsdGltZS5UcmFuc2xhdGVkSW1hZ2UuTG9jYWxpemVkSW1hZ2UaUwoOTG9j",
            "YWxpemVkSW1hZ2USCwoDdXJsGAEgAigJEhIKCm1lZGlhX3R5cGUYAiACKAkS",
            "EAoIbGFuZ3VhZ2UYAyABKAkqBgjoBxDQDyoGCKhGEJBOKgYI6AcQ0A8qBgio",
            "RhCQTiJDCgVTaGFwZRIQCghzaGFwZV9pZBgBIAEoCRIYChBlbmNvZGVkX3Bv",
            "bHlsaW5lGAIgASgJKgYI6AcQ0A8qBgioRhCQTkIdChtjb20uZ29vZ2xlLnRy",
            "YW5zaXQucmVhbHRpbWU="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedMessage), global::TransitRealtime.FeedMessage.Parser, new[]{ "Header", "Entity" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedHeader), global::TransitRealtime.FeedHeader.Parser, new[]{ "GtfsRealtimeVersion", "Incrementality", "Timestamp" }, null, new[]{ typeof(global::TransitRealtime.FeedHeader.Types.Incrementality) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.FeedEntity), global::TransitRealtime.FeedEntity.Parser, new[]{ "Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert", "Shape" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate), global::TransitRealtime.TripUpdate.Parser, new[]{ "Trip", "Vehicle", "StopTimeUpdate", "Timestamp", "Delay", "TripProperties" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.StopTimeEvent), global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Parser, new[]{ "Delay", "Time", "Uncertainty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate), global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Parser, new[]{ "StopSequence", "StopId", "Arrival", "Departure", "DepartureOccupancyStatus", "ScheduleRelationship", "StopTimeProperties" }, null, new[]{ typeof(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties), global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties.Parser, new[]{ "AssignedStopId" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripUpdate.Types.TripProperties), global::TransitRealtime.TripUpdate.Types.TripProperties.Parser, new[]{ "TripId", "StartDate", "StartTime", "ShapeId" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.VehiclePosition), global::TransitRealtime.VehiclePosition.Parser, new[]{ "Trip", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp", "CongestionLevel", "OccupancyStatus", "OccupancyPercentage", "MultiCarriageDetails" }, null, new[]{ typeof(global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus), typeof(global::TransitRealtime.VehiclePosition.Types.CongestionLevel), typeof(global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.VehiclePosition.Types.CarriageDetails), global::TransitRealtime.VehiclePosition.Types.CarriageDetails.Parser, new[]{ "Id", "Label", "OccupancyStatus", "OccupancyPercentage", "CarriageSequence" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.Alert), global::TransitRealtime.Alert.Parser, new[]{ "ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText", "TtsHeaderText", "TtsDescriptionText", "SeverityLevel", "Image", "ImageAlternativeText", "CauseDetail", "EffectDetail" }, null, new[]{ typeof(global::TransitRealtime.Alert.Types.Cause), typeof(global::TransitRealtime.Alert.Types.Effect), typeof(global::TransitRealtime.Alert.Types.SeverityLevel) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TimeRange), global::TransitRealtime.TimeRange.Parser, new[]{ "Start", "End" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.Position), global::TransitRealtime.Position.Parser, new[]{ "Latitude", "Longitude", "Bearing", "Odometer", "Speed" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TripDescriptor), global::TransitRealtime.TripDescriptor.Parser, new[]{ "TripId", "RouteId", "DirectionId", "StartTime", "StartDate", "ScheduleRelationship" }, null, new[]{ typeof(global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.VehicleDescriptor), global::TransitRealtime.VehicleDescriptor.Parser, new[]{ "Id", "Label", "LicensePlate", "WheelchairAccessible" }, null, new[]{ typeof(global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.EntitySelector), global::TransitRealtime.EntitySelector.Parser, new[]{ "AgencyId", "RouteId", "RouteType", "Trip", "StopId", "DirectionId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedString), global::TransitRealtime.TranslatedString.Parser, new[]{ "Translation" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedString.Types.Translation), global::TransitRealtime.TranslatedString.Types.Translation.Parser, new[]{ "Text", "Language" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedImage), global::TransitRealtime.TranslatedImage.Parser, new[]{ "LocalizedImage" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.TranslatedImage.Types.LocalizedImage), global::TransitRealtime.TranslatedImage.Types.LocalizedImage.Parser, new[]{ "Url", "MediaType", "Language" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::TransitRealtime.Shape), global::TransitRealtime.Shape.Parser, new[]{ "ShapeId", "EncodedPolyline" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The contents of a feed message.
  /// A feed is a continuous stream of feed messages. Each message in the stream is
  /// obtained as a response to an appropriate HTTP GET request.
  /// A realtime feed is always defined with relation to an existing GTFS feed.
  /// All the entity ids are resolved with respect to the GTFS feed.
  /// Note that "required" and "optional" as stated in this file refer to Protocol
  /// Buffer cardinality, not semantic cardinality.  See reference.md at
  /// https://github.com/google/transit/tree/master/gtfs-realtime for field
  /// semantic cardinality.
  /// </summary>
  public sealed partial class FeedMessage : pb::IExtendableMessage<FeedMessage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeedMessage> _parser = new pb::MessageParser<FeedMessage>(() => new FeedMessage());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<FeedMessage> _extensions;
    private pb::ExtensionSet<FeedMessage> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeedMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedMessage(FeedMessage other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      entity_ = other.entity_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedMessage Clone() {
      return new FeedMessage(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::TransitRealtime.FeedHeader header_;
    /// <summary>
    /// Metadata about this feed and feed message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.FeedHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "entity" field.</summary>
    public const int EntityFieldNumber = 2;
    private static readonly pb::FieldCodec<global::TransitRealtime.FeedEntity> _repeated_entity_codec
        = pb::FieldCodec.ForMessage(18, global::TransitRealtime.FeedEntity.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.FeedEntity> entity_ = new pbc::RepeatedField<global::TransitRealtime.FeedEntity>();
    /// <summary>
    /// Contents of the feed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.FeedEntity> Entity {
      get { return entity_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeedMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeedMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if(!entity_.Equals(other.entity_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      hash ^= entity_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      entity_.WriteTo(output, _repeated_entity_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      entity_.WriteTo(ref output, _repeated_entity_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      size += entity_.CalculateSize(_repeated_entity_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeedMessage other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::TransitRealtime.FeedHeader();
        }
        Header.MergeFrom(other.Header);
      }
      entity_.Add(other.entity_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::TransitRealtime.FeedHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            entity_.AddEntriesFrom(input, _repeated_entity_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::TransitRealtime.FeedHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            entity_.AddEntriesFrom(ref input, _repeated_entity_codec);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<FeedMessage, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<FeedMessage, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<FeedMessage, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<FeedMessage, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<FeedMessage, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// Metadata about a feed, included in feed messages.
  /// </summary>
  public sealed partial class FeedHeader : pb::IExtendableMessage<FeedHeader>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeedHeader> _parser = new pb::MessageParser<FeedHeader>(() => new FeedHeader());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<FeedHeader> _extensions;
    private pb::ExtensionSet<FeedHeader> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeedHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedHeader(FeedHeader other) : this() {
      _hasBits0 = other._hasBits0;
      gtfsRealtimeVersion_ = other.gtfsRealtimeVersion_;
      incrementality_ = other.incrementality_;
      timestamp_ = other.timestamp_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedHeader Clone() {
      return new FeedHeader(this);
    }

    /// <summary>Field number for the "gtfs_realtime_version" field.</summary>
    public const int GtfsRealtimeVersionFieldNumber = 1;
    private readonly static string GtfsRealtimeVersionDefaultValue = "";

    private string gtfsRealtimeVersion_;
    /// <summary>
    /// Version of the feed specification.
    /// The current version is 2.0.  Valid versions are "2.0", "1.0".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GtfsRealtimeVersion {
      get { return gtfsRealtimeVersion_ ?? GtfsRealtimeVersionDefaultValue; }
      set {
        gtfsRealtimeVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gtfs_realtime_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGtfsRealtimeVersion {
      get { return gtfsRealtimeVersion_ != null; }
    }
    /// <summary>Clears the value of the "gtfs_realtime_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGtfsRealtimeVersion() {
      gtfsRealtimeVersion_ = null;
    }

    /// <summary>Field number for the "incrementality" field.</summary>
    public const int IncrementalityFieldNumber = 2;
    private readonly static global::TransitRealtime.FeedHeader.Types.Incrementality IncrementalityDefaultValue = global::TransitRealtime.FeedHeader.Types.Incrementality.FullDataset;

    private global::TransitRealtime.FeedHeader.Types.Incrementality incrementality_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.FeedHeader.Types.Incrementality Incrementality {
      get { if ((_hasBits0 & 1) != 0) { return incrementality_; } else { return IncrementalityDefaultValue; } }
      set {
        _hasBits0 |= 1;
        incrementality_ = value;
      }
    }
    /// <summary>Gets whether the "incrementality" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIncrementality {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "incrementality" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIncrementality() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 3;
    private readonly static ulong TimestampDefaultValue = 0UL;

    private ulong timestamp_;
    /// <summary>
    /// This timestamp identifies the moment when the content of this feed has been
    /// created (in server time). In POSIX time (i.e., number of seconds since
    /// January 1st 1970 00:00:00 UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Timestamp {
      get { if ((_hasBits0 & 2) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
      set {
        _hasBits0 |= 2;
        timestamp_ = value;
      }
    }
    /// <summary>Gets whether the "timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestamp {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestamp() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeedHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeedHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GtfsRealtimeVersion != other.GtfsRealtimeVersion) return false;
      if (Incrementality != other.Incrementality) return false;
      if (Timestamp != other.Timestamp) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGtfsRealtimeVersion) hash ^= GtfsRealtimeVersion.GetHashCode();
      if (HasIncrementality) hash ^= Incrementality.GetHashCode();
      if (HasTimestamp) hash ^= Timestamp.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGtfsRealtimeVersion) {
        output.WriteRawTag(10);
        output.WriteString(GtfsRealtimeVersion);
      }
      if (HasIncrementality) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Incrementality);
      }
      if (HasTimestamp) {
        output.WriteRawTag(24);
        output.WriteUInt64(Timestamp);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGtfsRealtimeVersion) {
        output.WriteRawTag(10);
        output.WriteString(GtfsRealtimeVersion);
      }
      if (HasIncrementality) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Incrementality);
      }
      if (HasTimestamp) {
        output.WriteRawTag(24);
        output.WriteUInt64(Timestamp);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGtfsRealtimeVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GtfsRealtimeVersion);
      }
      if (HasIncrementality) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Incrementality);
      }
      if (HasTimestamp) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeedHeader other) {
      if (other == null) {
        return;
      }
      if (other.HasGtfsRealtimeVersion) {
        GtfsRealtimeVersion = other.GtfsRealtimeVersion;
      }
      if (other.HasIncrementality) {
        Incrementality = other.Incrementality;
      }
      if (other.HasTimestamp) {
        Timestamp = other.Timestamp;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            GtfsRealtimeVersion = input.ReadString();
            break;
          }
          case 16: {
            Incrementality = (global::TransitRealtime.FeedHeader.Types.Incrementality) input.ReadEnum();
            break;
          }
          case 24: {
            Timestamp = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            GtfsRealtimeVersion = input.ReadString();
            break;
          }
          case 16: {
            Incrementality = (global::TransitRealtime.FeedHeader.Types.Incrementality) input.ReadEnum();
            break;
          }
          case 24: {
            Timestamp = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<FeedHeader, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<FeedHeader, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<FeedHeader, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<FeedHeader, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<FeedHeader, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FeedHeader message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Determines whether the current fetch is incremental.  Currently,
      /// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
      /// that use this mode.  There are discussions on the GTFS Realtime mailing
      /// list around fully specifying the behavior of DIFFERENTIAL mode and the
      /// documentation will be updated when those discussions are finalized.
      /// </summary>
      public enum Incrementality {
        [pbr::OriginalName("FULL_DATASET")] FullDataset = 0,
        [pbr::OriginalName("DIFFERENTIAL")] Differential = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// A definition (or update) of an entity in the transit feed.
  /// </summary>
  public sealed partial class FeedEntity : pb::IExtendableMessage<FeedEntity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FeedEntity> _parser = new pb::MessageParser<FeedEntity>(() => new FeedEntity());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<FeedEntity> _extensions;
    private pb::ExtensionSet<FeedEntity> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FeedEntity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedEntity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedEntity(FeedEntity other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      isDeleted_ = other.isDeleted_;
      tripUpdate_ = other.tripUpdate_ != null ? other.tripUpdate_.Clone() : null;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      alert_ = other.alert_ != null ? other.alert_.Clone() : null;
      shape_ = other.shape_ != null ? other.shape_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FeedEntity Clone() {
      return new FeedEntity(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static string IdDefaultValue = "";

    private string id_;
    /// <summary>
    /// The ids are used only to provide incrementality support. The id should be
    /// unique within a FeedMessage. Consequent FeedMessages may contain
    /// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    /// FeedEntity with some id will replace the old FeedEntity with the same id
    /// (or delete it - see is_deleted below).
    /// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    /// feed must be specified by explicit selectors (see EntitySelector below for
    /// more info).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Id {
      get { return id_ ?? IdDefaultValue; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return id_ != null; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      id_ = null;
    }

    /// <summary>Field number for the "is_deleted" field.</summary>
    public const int IsDeletedFieldNumber = 2;
    private readonly static bool IsDeletedDefaultValue = false;

    private bool isDeleted_;
    /// <summary>
    /// Whether this entity is to be deleted. Relevant only for incremental
    /// fetches.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsDeleted {
      get { if ((_hasBits0 & 1) != 0) { return isDeleted_; } else { return IsDeletedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isDeleted_ = value;
      }
    }
    /// <summary>Gets whether the "is_deleted" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIsDeleted {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_deleted" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIsDeleted() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "trip_update" field.</summary>
    public const int TripUpdateFieldNumber = 3;
    private global::TransitRealtime.TripUpdate tripUpdate_;
    /// <summary>
    /// Data about the entity itself. Exactly one of the following fields must be
    /// present (unless the entity is being deleted).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripUpdate TripUpdate {
      get { return tripUpdate_; }
      set {
        tripUpdate_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 4;
    private global::TransitRealtime.VehiclePosition vehicle_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehiclePosition Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "alert" field.</summary>
    public const int AlertFieldNumber = 5;
    private global::TransitRealtime.Alert alert_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Alert Alert {
      get { return alert_; }
      set {
        alert_ = value;
      }
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 6;
    private global::TransitRealtime.Shape shape_;
    /// <summary>
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Shape Shape {
      get { return shape_; }
      set {
        shape_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FeedEntity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FeedEntity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (IsDeleted != other.IsDeleted) return false;
      if (!object.Equals(TripUpdate, other.TripUpdate)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(Alert, other.Alert)) return false;
      if (!object.Equals(Shape, other.Shape)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasIsDeleted) hash ^= IsDeleted.GetHashCode();
      if (tripUpdate_ != null) hash ^= TripUpdate.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (alert_ != null) hash ^= Alert.GetHashCode();
      if (shape_ != null) hash ^= Shape.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasIsDeleted) {
        output.WriteRawTag(16);
        output.WriteBool(IsDeleted);
      }
      if (tripUpdate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TripUpdate);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (alert_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Alert);
      }
      if (shape_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Shape);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasIsDeleted) {
        output.WriteRawTag(16);
        output.WriteBool(IsDeleted);
      }
      if (tripUpdate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TripUpdate);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (alert_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Alert);
      }
      if (shape_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Shape);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (HasIsDeleted) {
        size += 1 + 1;
      }
      if (tripUpdate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TripUpdate);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (alert_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Alert);
      }
      if (shape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FeedEntity other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasIsDeleted) {
        IsDeleted = other.IsDeleted;
      }
      if (other.tripUpdate_ != null) {
        if (tripUpdate_ == null) {
          TripUpdate = new global::TransitRealtime.TripUpdate();
        }
        TripUpdate.MergeFrom(other.TripUpdate);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::TransitRealtime.VehiclePosition();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.alert_ != null) {
        if (alert_ == null) {
          Alert = new global::TransitRealtime.Alert();
        }
        Alert.MergeFrom(other.Alert);
      }
      if (other.shape_ != null) {
        if (shape_ == null) {
          Shape = new global::TransitRealtime.Shape();
        }
        Shape.MergeFrom(other.Shape);
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 16: {
            IsDeleted = input.ReadBool();
            break;
          }
          case 26: {
            if (tripUpdate_ == null) {
              TripUpdate = new global::TransitRealtime.TripUpdate();
            }
            input.ReadMessage(TripUpdate);
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehiclePosition();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (alert_ == null) {
              Alert = new global::TransitRealtime.Alert();
            }
            input.ReadMessage(Alert);
            break;
          }
          case 50: {
            if (shape_ == null) {
              Shape = new global::TransitRealtime.Shape();
            }
            input.ReadMessage(Shape);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 16: {
            IsDeleted = input.ReadBool();
            break;
          }
          case 26: {
            if (tripUpdate_ == null) {
              TripUpdate = new global::TransitRealtime.TripUpdate();
            }
            input.ReadMessage(TripUpdate);
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehiclePosition();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (alert_ == null) {
              Alert = new global::TransitRealtime.Alert();
            }
            input.ReadMessage(Alert);
            break;
          }
          case 50: {
            if (shape_ == null) {
              Shape = new global::TransitRealtime.Shape();
            }
            input.ReadMessage(Shape);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<FeedEntity, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<FeedEntity, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<FeedEntity, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<FeedEntity, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<FeedEntity, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// Realtime update of the progress of a vehicle along a trip.
  /// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
  /// - A trip that proceeds along the schedule.
  /// - A trip that proceeds along a route but has no fixed schedule.
  /// - A trip that have been added or removed with regard to schedule.
  ///
  /// The updates can be for future, predicted arrival/departure events, or for
  /// past events that already occurred.
  /// Normally, updates should get more precise and more certain (see
  /// uncertainty below) as the events gets closer to current time.
  /// Even if that is not possible, the information for past events should be
  /// precise and certain. In particular, if an update points to time in the past
  /// but its update's uncertainty is not 0, the client should conclude that the
  /// update is a (wrong) prediction and that the trip has not completed yet.
  ///
  /// Note that the update can describe a trip that is already completed.
  /// To this end, it is enough to provide an update for the last stop of the trip.
  /// If the time of that is in the past, the client will conclude from that that
  /// the whole trip is in the past (it is possible, although inconsequential, to
  /// also provide updates for preceding stops).
  /// This option is most relevant for a trip that has completed ahead of schedule,
  /// but according to the schedule, the trip is still proceeding at the current
  /// time. Removing the updates for this trip could make the client assume
  /// that the trip is still proceeding.
  /// Note that the feed provider is allowed, but not required, to purge past
  /// updates - this is one case where this would be practically useful.
  /// </summary>
  public sealed partial class TripUpdate : pb::IExtendableMessage<TripUpdate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TripUpdate> _parser = new pb::MessageParser<TripUpdate>(() => new TripUpdate());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TripUpdate> _extensions;
    private pb::ExtensionSet<TripUpdate> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TripUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripUpdate(TripUpdate other) : this() {
      _hasBits0 = other._hasBits0;
      trip_ = other.trip_ != null ? other.trip_.Clone() : null;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      stopTimeUpdate_ = other.stopTimeUpdate_.Clone();
      timestamp_ = other.timestamp_;
      delay_ = other.delay_;
      tripProperties_ = other.tripProperties_ != null ? other.tripProperties_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripUpdate Clone() {
      return new TripUpdate(this);
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 1;
    private global::TransitRealtime.TripDescriptor trip_;
    /// <summary>
    /// The Trip that this message applies to. There can be at most one
    /// TripUpdate entity for each actual trip instance.
    /// If there is none, that means there is no prediction information available.
    /// It does *not* mean that the trip is progressing according to schedule.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 3;
    private global::TransitRealtime.VehicleDescriptor vehicle_;
    /// <summary>
    /// Additional information on the vehicle that is serving this trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehicleDescriptor Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "stop_time_update" field.</summary>
    public const int StopTimeUpdateFieldNumber = 2;
    private static readonly pb::FieldCodec<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> _repeated_stopTimeUpdate_codec
        = pb::FieldCodec.ForMessage(18, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> stopTimeUpdate_ = new pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate>();
    /// <summary>
    /// Updates to StopTimes for the trip (both future, i.e., predictions, and in
    /// some cases, past ones, i.e., those that already happened).
    /// The updates must be sorted by stop_sequence, and apply for all the
    /// following stops of the trip up to the next specified one.
    ///
    /// Example 1:
    /// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
    /// delay of 0 for stop_sequence of the current stop means that the trip is
    /// exactly on time.
    ///
    /// Example 2:
    /// For the same trip instance, 3 StopTimeUpdates are provided:
    /// - delay of 5 min for stop_sequence 3
    /// - delay of 1 min for stop_sequence 8
    /// - delay of unspecified duration for stop_sequence 10
    /// This will be interpreted as:
    /// - stop_sequences 3,4,5,6,7 have delay of 5 min.
    /// - stop_sequences 8,9 have delay of 1 min.
    /// - stop_sequences 10,... have unknown delay.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdate {
      get { return stopTimeUpdate_; }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 4;
    private readonly static ulong TimestampDefaultValue = 0UL;

    private ulong timestamp_;
    /// <summary>
    /// The most recent moment at which the vehicle's real-time progress was measured
    /// to estimate StopTimes in the future. When StopTimes in the past are provided,
    /// arrival/departure times may be earlier than this value. In POSIX
    /// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Timestamp {
      get { if ((_hasBits0 & 1) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
      set {
        _hasBits0 |= 1;
        timestamp_ = value;
      }
    }
    /// <summary>Gets whether the "timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestamp {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestamp() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "delay" field.</summary>
    public const int DelayFieldNumber = 5;
    private readonly static int DelayDefaultValue = 0;

    private int delay_;
    /// <summary>
    /// The current schedule deviation for the trip.  Delay should only be
    /// specified when the prediction is given relative to some existing schedule
    /// in GTFS.
    ///
    /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
    /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
    /// means that the vehicle is exactly on time.
    ///
    /// Delay information in StopTimeUpdates take precedent of trip-level delay
    /// information, such that trip-level delay is only propagated until the next
    /// stop along the trip with a StopTimeUpdate delay value specified.
    ///
    /// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    /// value indicating when the delay value was last updated, in order to
    /// evaluate the freshness of the data.
    ///
    /// NOTE: This field is still experimental, and subject to change. It may be
    /// formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Delay {
      get { if ((_hasBits0 & 2) != 0) { return delay_; } else { return DelayDefaultValue; } }
      set {
        _hasBits0 |= 2;
        delay_ = value;
      }
    }
    /// <summary>Gets whether the "delay" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDelay {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "delay" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDelay() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "trip_properties" field.</summary>
    public const int TripPropertiesFieldNumber = 6;
    private global::TransitRealtime.TripUpdate.Types.TripProperties tripProperties_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripUpdate.Types.TripProperties TripProperties {
      get { return tripProperties_; }
      set {
        tripProperties_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TripUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TripUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Trip, other.Trip)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if(!stopTimeUpdate_.Equals(other.stopTimeUpdate_)) return false;
      if (Timestamp != other.Timestamp) return false;
      if (Delay != other.Delay) return false;
      if (!object.Equals(TripProperties, other.TripProperties)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      hash ^= stopTimeUpdate_.GetHashCode();
      if (HasTimestamp) hash ^= Timestamp.GetHashCode();
      if (HasDelay) hash ^= Delay.GetHashCode();
      if (tripProperties_ != null) hash ^= TripProperties.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      stopTimeUpdate_.WriteTo(output, _repeated_stopTimeUpdate_codec);
      if (vehicle_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Vehicle);
      }
      if (HasTimestamp) {
        output.WriteRawTag(32);
        output.WriteUInt64(Timestamp);
      }
      if (HasDelay) {
        output.WriteRawTag(40);
        output.WriteInt32(Delay);
      }
      if (tripProperties_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TripProperties);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      stopTimeUpdate_.WriteTo(ref output, _repeated_stopTimeUpdate_codec);
      if (vehicle_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Vehicle);
      }
      if (HasTimestamp) {
        output.WriteRawTag(32);
        output.WriteUInt64(Timestamp);
      }
      if (HasDelay) {
        output.WriteRawTag(40);
        output.WriteInt32(Delay);
      }
      if (tripProperties_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(TripProperties);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      size += stopTimeUpdate_.CalculateSize(_repeated_stopTimeUpdate_codec);
      if (HasTimestamp) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (HasDelay) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
      }
      if (tripProperties_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TripProperties);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TripUpdate other) {
      if (other == null) {
        return;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          Trip = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::TransitRealtime.VehicleDescriptor();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      stopTimeUpdate_.Add(other.stopTimeUpdate_);
      if (other.HasTimestamp) {
        Timestamp = other.Timestamp;
      }
      if (other.HasDelay) {
        Delay = other.Delay;
      }
      if (other.tripProperties_ != null) {
        if (tripProperties_ == null) {
          TripProperties = new global::TransitRealtime.TripUpdate.Types.TripProperties();
        }
        TripProperties.MergeFrom(other.TripProperties);
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 18: {
            stopTimeUpdate_.AddEntriesFrom(input, _repeated_stopTimeUpdate_codec);
            break;
          }
          case 26: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 32: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 40: {
            Delay = input.ReadInt32();
            break;
          }
          case 50: {
            if (tripProperties_ == null) {
              TripProperties = new global::TransitRealtime.TripUpdate.Types.TripProperties();
            }
            input.ReadMessage(TripProperties);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 18: {
            stopTimeUpdate_.AddEntriesFrom(ref input, _repeated_stopTimeUpdate_codec);
            break;
          }
          case 26: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 32: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 40: {
            Delay = input.ReadInt32();
            break;
          }
          case 50: {
            if (tripProperties_ == null) {
              TripProperties = new global::TransitRealtime.TripUpdate.Types.TripProperties();
            }
            input.ReadMessage(TripProperties);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TripUpdate, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TripUpdate, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TripUpdate, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TripUpdate, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TripUpdate, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TripUpdate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Timing information for a single predicted event (either arrival or
      /// departure).
      /// Timing consists of delay and/or estimated time, and uncertainty.
      /// - delay should be used when the prediction is given relative to some
      ///   existing schedule in GTFS.
      /// - time should be given whether there is a predicted schedule or not. If
      ///   both time and delay are specified, time will take precedence
      ///   (although normally, time, if given for a scheduled trip, should be
      ///   equal to scheduled time in GTFS + delay).
      ///
      /// Uncertainty applies equally to both time and delay.
      /// The uncertainty roughly specifies the expected error in true delay (but
      /// note, we don't yet define its precise statistical meaning). It's possible
      /// for the uncertainty to be 0, for example for trains that are driven under
      /// computer timing control.
      /// </summary>
      public sealed partial class StopTimeEvent : pb::IExtendableMessage<StopTimeEvent>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<StopTimeEvent> _parser = new pb::MessageParser<StopTimeEvent>(() => new StopTimeEvent());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<StopTimeEvent> _extensions;
        private pb::ExtensionSet<StopTimeEvent> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<StopTimeEvent> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TripUpdate.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeEvent() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeEvent(StopTimeEvent other) : this() {
          _hasBits0 = other._hasBits0;
          delay_ = other.delay_;
          time_ = other.time_;
          uncertainty_ = other.uncertainty_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeEvent Clone() {
          return new StopTimeEvent(this);
        }

        /// <summary>Field number for the "delay" field.</summary>
        public const int DelayFieldNumber = 1;
        private readonly static int DelayDefaultValue = 0;

        private int delay_;
        /// <summary>
        /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
        /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
        /// means that the vehicle is exactly on time.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Delay {
          get { if ((_hasBits0 & 1) != 0) { return delay_; } else { return DelayDefaultValue; } }
          set {
            _hasBits0 |= 1;
            delay_ = value;
          }
        }
        /// <summary>Gets whether the "delay" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDelay {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "delay" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDelay() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "time" field.</summary>
        public const int TimeFieldNumber = 2;
        private readonly static long TimeDefaultValue = 0L;

        private long time_;
        /// <summary>
        /// Event as absolute time.
        /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        /// UTC).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long Time {
          get { if ((_hasBits0 & 2) != 0) { return time_; } else { return TimeDefaultValue; } }
          set {
            _hasBits0 |= 2;
            time_ = value;
          }
        }
        /// <summary>Gets whether the "time" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTime {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "time" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTime() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "uncertainty" field.</summary>
        public const int UncertaintyFieldNumber = 3;
        private readonly static int UncertaintyDefaultValue = 0;

        private int uncertainty_;
        /// <summary>
        /// If uncertainty is omitted, it is interpreted as unknown.
        /// If the prediction is unknown or too uncertain, the delay (or time) field
        /// should be empty. In such case, the uncertainty field is ignored.
        /// To specify a completely certain prediction, set its uncertainty to 0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Uncertainty {
          get { if ((_hasBits0 & 4) != 0) { return uncertainty_; } else { return UncertaintyDefaultValue; } }
          set {
            _hasBits0 |= 4;
            uncertainty_ = value;
          }
        }
        /// <summary>Gets whether the "uncertainty" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUncertainty {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "uncertainty" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUncertainty() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as StopTimeEvent);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(StopTimeEvent other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Delay != other.Delay) return false;
          if (Time != other.Time) return false;
          if (Uncertainty != other.Uncertainty) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasDelay) hash ^= Delay.GetHashCode();
          if (HasTime) hash ^= Time.GetHashCode();
          if (HasUncertainty) hash ^= Uncertainty.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasDelay) {
            output.WriteRawTag(8);
            output.WriteInt32(Delay);
          }
          if (HasTime) {
            output.WriteRawTag(16);
            output.WriteInt64(Time);
          }
          if (HasUncertainty) {
            output.WriteRawTag(24);
            output.WriteInt32(Uncertainty);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasDelay) {
            output.WriteRawTag(8);
            output.WriteInt32(Delay);
          }
          if (HasTime) {
            output.WriteRawTag(16);
            output.WriteInt64(Time);
          }
          if (HasUncertainty) {
            output.WriteRawTag(24);
            output.WriteInt32(Uncertainty);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasDelay) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Delay);
          }
          if (HasTime) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Time);
          }
          if (HasUncertainty) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Uncertainty);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(StopTimeEvent other) {
          if (other == null) {
            return;
          }
          if (other.HasDelay) {
            Delay = other.Delay;
          }
          if (other.HasTime) {
            Time = other.Time;
          }
          if (other.HasUncertainty) {
            Uncertainty = other.Uncertainty;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 8: {
                Delay = input.ReadInt32();
                break;
              }
              case 16: {
                Time = input.ReadInt64();
                break;
              }
              case 24: {
                Uncertainty = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 8: {
                Delay = input.ReadInt32();
                break;
              }
              case 16: {
                Time = input.ReadInt64();
                break;
              }
              case 24: {
                Uncertainty = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<StopTimeEvent, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<StopTimeEvent, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

      /// <summary>
      /// Realtime update for arrival and/or departure events for a given stop on a
      /// trip. Updates can be supplied for both past and future events.
      /// The producer is allowed, although not required, to drop past events.
      /// </summary>
      public sealed partial class StopTimeUpdate : pb::IExtendableMessage<StopTimeUpdate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<StopTimeUpdate> _parser = new pb::MessageParser<StopTimeUpdate>(() => new StopTimeUpdate());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<StopTimeUpdate> _extensions;
        private pb::ExtensionSet<StopTimeUpdate> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<StopTimeUpdate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TripUpdate.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeUpdate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeUpdate(StopTimeUpdate other) : this() {
          _hasBits0 = other._hasBits0;
          stopSequence_ = other.stopSequence_;
          stopId_ = other.stopId_;
          arrival_ = other.arrival_ != null ? other.arrival_.Clone() : null;
          departure_ = other.departure_ != null ? other.departure_.Clone() : null;
          departureOccupancyStatus_ = other.departureOccupancyStatus_;
          scheduleRelationship_ = other.scheduleRelationship_;
          stopTimeProperties_ = other.stopTimeProperties_ != null ? other.stopTimeProperties_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StopTimeUpdate Clone() {
          return new StopTimeUpdate(this);
        }

        /// <summary>Field number for the "stop_sequence" field.</summary>
        public const int StopSequenceFieldNumber = 1;
        private readonly static uint StopSequenceDefaultValue = 0;

        private uint stopSequence_;
        /// <summary>
        /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint StopSequence {
          get { if ((_hasBits0 & 1) != 0) { return stopSequence_; } else { return StopSequenceDefaultValue; } }
          set {
            _hasBits0 |= 1;
            stopSequence_ = value;
          }
        }
        /// <summary>Gets whether the "stop_sequence" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStopSequence {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "stop_sequence" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStopSequence() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "stop_id" field.</summary>
        public const int StopIdFieldNumber = 4;
        private readonly static string StopIdDefaultValue = "";

        private string stopId_;
        /// <summary>
        /// Must be the same as in stops.txt in the corresponding GTFS feed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StopId {
          get { return stopId_ ?? StopIdDefaultValue; }
          set {
            stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "stop_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStopId {
          get { return stopId_ != null; }
        }
        /// <summary>Clears the value of the "stop_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStopId() {
          stopId_ = null;
        }

        /// <summary>Field number for the "arrival" field.</summary>
        public const int ArrivalFieldNumber = 2;
        private global::TransitRealtime.TripUpdate.Types.StopTimeEvent arrival_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Arrival {
          get { return arrival_; }
          set {
            arrival_ = value;
          }
        }

        /// <summary>Field number for the "departure" field.</summary>
        public const int DepartureFieldNumber = 3;
        private global::TransitRealtime.TripUpdate.Types.StopTimeEvent departure_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Departure {
          get { return departure_; }
          set {
            departure_ = value;
          }
        }

        /// <summary>Field number for the "departure_occupancy_status" field.</summary>
        public const int DepartureOccupancyStatusFieldNumber = 7;
        private readonly static global::TransitRealtime.VehiclePosition.Types.OccupancyStatus DepartureOccupancyStatusDefaultValue = global::TransitRealtime.VehiclePosition.Types.OccupancyStatus.Empty;

        private global::TransitRealtime.VehiclePosition.Types.OccupancyStatus departureOccupancyStatus_;
        /// <summary>
        /// Expected occupancy after departure from the given stop.
        /// Should be provided only for future stops.
        /// In order to provide departure_occupancy_status without either arrival or
        /// departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus DepartureOccupancyStatus {
          get { if ((_hasBits0 & 4) != 0) { return departureOccupancyStatus_; } else { return DepartureOccupancyStatusDefaultValue; } }
          set {
            _hasBits0 |= 4;
            departureOccupancyStatus_ = value;
          }
        }
        /// <summary>Gets whether the "departure_occupancy_status" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDepartureOccupancyStatus {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "departure_occupancy_status" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDepartureOccupancyStatus() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "schedule_relationship" field.</summary>
        public const int ScheduleRelationshipFieldNumber = 5;
        private readonly static global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationshipDefaultValue = global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship.Scheduled;

        private global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship scheduleRelationship_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationship {
          get { if ((_hasBits0 & 2) != 0) { return scheduleRelationship_; } else { return ScheduleRelationshipDefaultValue; } }
          set {
            _hasBits0 |= 2;
            scheduleRelationship_ = value;
          }
        }
        /// <summary>Gets whether the "schedule_relationship" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasScheduleRelationship {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "schedule_relationship" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearScheduleRelationship() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "stop_time_properties" field.</summary>
        public const int StopTimePropertiesFieldNumber = 6;
        private global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties stopTimeProperties_;
        /// <summary>
        /// Realtime updates for certain properties defined within GTFS stop_times.txt
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties StopTimeProperties {
          get { return stopTimeProperties_; }
          set {
            stopTimeProperties_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as StopTimeUpdate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(StopTimeUpdate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (StopSequence != other.StopSequence) return false;
          if (StopId != other.StopId) return false;
          if (!object.Equals(Arrival, other.Arrival)) return false;
          if (!object.Equals(Departure, other.Departure)) return false;
          if (DepartureOccupancyStatus != other.DepartureOccupancyStatus) return false;
          if (ScheduleRelationship != other.ScheduleRelationship) return false;
          if (!object.Equals(StopTimeProperties, other.StopTimeProperties)) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasStopSequence) hash ^= StopSequence.GetHashCode();
          if (HasStopId) hash ^= StopId.GetHashCode();
          if (arrival_ != null) hash ^= Arrival.GetHashCode();
          if (departure_ != null) hash ^= Departure.GetHashCode();
          if (HasDepartureOccupancyStatus) hash ^= DepartureOccupancyStatus.GetHashCode();
          if (HasScheduleRelationship) hash ^= ScheduleRelationship.GetHashCode();
          if (stopTimeProperties_ != null) hash ^= StopTimeProperties.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasStopSequence) {
            output.WriteRawTag(8);
            output.WriteUInt32(StopSequence);
          }
          if (arrival_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Arrival);
          }
          if (departure_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Departure);
          }
          if (HasStopId) {
            output.WriteRawTag(34);
            output.WriteString(StopId);
          }
          if (HasScheduleRelationship) {
            output.WriteRawTag(40);
            output.WriteEnum((int) ScheduleRelationship);
          }
          if (stopTimeProperties_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(StopTimeProperties);
          }
          if (HasDepartureOccupancyStatus) {
            output.WriteRawTag(56);
            output.WriteEnum((int) DepartureOccupancyStatus);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasStopSequence) {
            output.WriteRawTag(8);
            output.WriteUInt32(StopSequence);
          }
          if (arrival_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Arrival);
          }
          if (departure_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Departure);
          }
          if (HasStopId) {
            output.WriteRawTag(34);
            output.WriteString(StopId);
          }
          if (HasScheduleRelationship) {
            output.WriteRawTag(40);
            output.WriteEnum((int) ScheduleRelationship);
          }
          if (stopTimeProperties_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(StopTimeProperties);
          }
          if (HasDepartureOccupancyStatus) {
            output.WriteRawTag(56);
            output.WriteEnum((int) DepartureOccupancyStatus);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasStopSequence) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StopSequence);
          }
          if (HasStopId) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
          }
          if (arrival_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Arrival);
          }
          if (departure_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Departure);
          }
          if (HasDepartureOccupancyStatus) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DepartureOccupancyStatus);
          }
          if (HasScheduleRelationship) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScheduleRelationship);
          }
          if (stopTimeProperties_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StopTimeProperties);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(StopTimeUpdate other) {
          if (other == null) {
            return;
          }
          if (other.HasStopSequence) {
            StopSequence = other.StopSequence;
          }
          if (other.HasStopId) {
            StopId = other.StopId;
          }
          if (other.arrival_ != null) {
            if (arrival_ == null) {
              Arrival = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
            }
            Arrival.MergeFrom(other.Arrival);
          }
          if (other.departure_ != null) {
            if (departure_ == null) {
              Departure = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
            }
            Departure.MergeFrom(other.Departure);
          }
          if (other.HasDepartureOccupancyStatus) {
            DepartureOccupancyStatus = other.DepartureOccupancyStatus;
          }
          if (other.HasScheduleRelationship) {
            ScheduleRelationship = other.ScheduleRelationship;
          }
          if (other.stopTimeProperties_ != null) {
            if (stopTimeProperties_ == null) {
              StopTimeProperties = new global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties();
            }
            StopTimeProperties.MergeFrom(other.StopTimeProperties);
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 8: {
                StopSequence = input.ReadUInt32();
                break;
              }
              case 18: {
                if (arrival_ == null) {
                  Arrival = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Arrival);
                break;
              }
              case 26: {
                if (departure_ == null) {
                  Departure = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Departure);
                break;
              }
              case 34: {
                StopId = input.ReadString();
                break;
              }
              case 40: {
                ScheduleRelationship = (global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) input.ReadEnum();
                break;
              }
              case 50: {
                if (stopTimeProperties_ == null) {
                  StopTimeProperties = new global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties();
                }
                input.ReadMessage(StopTimeProperties);
                break;
              }
              case 56: {
                DepartureOccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 8: {
                StopSequence = input.ReadUInt32();
                break;
              }
              case 18: {
                if (arrival_ == null) {
                  Arrival = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Arrival);
                break;
              }
              case 26: {
                if (departure_ == null) {
                  Departure = new global::TransitRealtime.TripUpdate.Types.StopTimeEvent();
                }
                input.ReadMessage(Departure);
                break;
              }
              case 34: {
                StopId = input.ReadString();
                break;
              }
              case 40: {
                ScheduleRelationship = (global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship) input.ReadEnum();
                break;
              }
              case 50: {
                if (stopTimeProperties_ == null) {
                  StopTimeProperties = new global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.StopTimeProperties();
                }
                input.ReadMessage(StopTimeProperties);
                break;
              }
              case 56: {
                DepartureOccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<StopTimeUpdate, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<StopTimeUpdate, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

        #region Nested types
        /// <summary>Container for nested types declared in the StopTimeUpdate message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// The relation between the StopTimeEvents and the static schedule.
          /// </summary>
          public enum ScheduleRelationship {
            /// <summary>
            /// The vehicle is proceeding in accordance with its static schedule of
            /// stops, although not necessarily according to the times of the schedule.
            /// At least one of arrival and departure must be provided. If the schedule
            /// for this stop contains both arrival and departure times then so must
            /// this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
            /// should not have a SCHEDULED value and should use UNSCHEDULED instead.
            /// </summary>
            [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
            /// <summary>
            /// The stop is skipped, i.e., the vehicle will not stop at this stop.
            /// Arrival and departure are optional.
            /// </summary>
            [pbr::OriginalName("SKIPPED")] Skipped = 1,
            /// <summary>
            /// No StopTimeEvents are given for this stop.
            /// The main intention for this value is to give time predictions only for
            /// part of a trip, i.e., if the last update for a trip has a NO_DATA
            /// specifier, then StopTimeEvents for the rest of the stops in the trip
            /// are considered to be unspecified as well.
            /// Neither arrival nor departure should be supplied.
            /// </summary>
            [pbr::OriginalName("NO_DATA")] NoData = 2,
            /// <summary>
            /// The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
            /// This value should not be used for trips that are not defined in GTFS frequencies.txt,
            /// or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
            /// with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
            /// NOTE: This field is still experimental, and subject to change. It may be
            /// formally adopted in the future.
            /// </summary>
            [pbr::OriginalName("UNSCHEDULED")] Unscheduled = 3,
          }

          /// <summary>
          /// Provides the updated values for the stop time.
          /// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
          /// </summary>
          public sealed partial class StopTimeProperties : pb::IExtendableMessage<StopTimeProperties>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<StopTimeProperties> _parser = new pb::MessageParser<StopTimeProperties>(() => new StopTimeProperties());
            private pb::UnknownFieldSet _unknownFields;
            private pb::ExtensionSet<StopTimeProperties> _extensions;
            private pb::ExtensionSet<StopTimeProperties> _Extensions { get { return _extensions; } }
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<StopTimeProperties> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StopTimeProperties() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StopTimeProperties(StopTimeProperties other) : this() {
              assignedStopId_ = other.assignedStopId_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
              _extensions = pb::ExtensionSet.Clone(other._extensions);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StopTimeProperties Clone() {
              return new StopTimeProperties(this);
            }

            /// <summary>Field number for the "assigned_stop_id" field.</summary>
            public const int AssignedStopIdFieldNumber = 1;
            private readonly static string AssignedStopIdDefaultValue = "";

            private string assignedStopId_;
            /// <summary>
            /// Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
            /// The new assigned_stop_id should not result in a significantly different trip experience for the end user than
            /// the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
            /// "unusual change" if the new stop was presented within an app without any additional context.
            /// For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
            /// same station as the stop originally defined in GTFS stop_times.txt.
            /// To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
            /// StopTimeUpdate.schedule_relationship = NO_DATA.
            /// If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
            /// `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
            /// Platform assignments should be reflected in other GTFS-realtime fields as well
            /// (e.g., `VehiclePosition.stop_id`).
            /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string AssignedStopId {
              get { return assignedStopId_ ?? AssignedStopIdDefaultValue; }
              set {
                assignedStopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "assigned_stop_id" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAssignedStopId {
              get { return assignedStopId_ != null; }
            }
            /// <summary>Clears the value of the "assigned_stop_id" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAssignedStopId() {
              assignedStopId_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as StopTimeProperties);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(StopTimeProperties other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (AssignedStopId != other.AssignedStopId) return false;
              if (!Equals(_extensions, other._extensions)) {
                return false;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasAssignedStopId) hash ^= AssignedStopId.GetHashCode();
              if (_extensions != null) {
                hash ^= _extensions.GetHashCode();
              }
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasAssignedStopId) {
                output.WriteRawTag(10);
                output.WriteString(AssignedStopId);
              }
              if (_extensions != null) {
                _extensions.WriteTo(output);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasAssignedStopId) {
                output.WriteRawTag(10);
                output.WriteString(AssignedStopId);
              }
              if (_extensions != null) {
                _extensions.WriteTo(ref output);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasAssignedStopId) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(AssignedStopId);
              }
              if (_extensions != null) {
                size += _extensions.CalculateSize();
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(StopTimeProperties other) {
              if (other == null) {
                return;
              }
              if (other.HasAssignedStopId) {
                AssignedStopId = other.AssignedStopId;
              }
              pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                      _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    }
                    break;
                  case 10: {
                    AssignedStopId = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                      _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    }
                    break;
                  case 10: {
                    AssignedStopId = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

            public TValue GetExtension<TValue>(pb::Extension<StopTimeProperties, TValue> extension) {
              return pb::ExtensionSet.Get(ref _extensions, extension);
            }
            public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<StopTimeProperties, TValue> extension) {
              return pb::ExtensionSet.Get(ref _extensions, extension);
            }
            public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<StopTimeProperties, TValue> extension) {
              return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
            }
            public void SetExtension<TValue>(pb::Extension<StopTimeProperties, TValue> extension, TValue value) {
              pb::ExtensionSet.Set(ref _extensions, extension, value);
            }
            public bool HasExtension<TValue>(pb::Extension<StopTimeProperties, TValue> extension) {
              return pb::ExtensionSet.Has(ref _extensions, extension);
            }
            public void ClearExtension<TValue>(pb::Extension<StopTimeProperties, TValue> extension) {
              pb::ExtensionSet.Clear(ref _extensions, extension);
            }
            public void ClearExtension<TValue>(pb::RepeatedExtension<StopTimeProperties, TValue> extension) {
              pb::ExtensionSet.Clear(ref _extensions, extension);
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
      /// trip_id, start_date, and start_time of a DUPLICATED trip. 
      /// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
      /// </summary>
      public sealed partial class TripProperties : pb::IExtendableMessage<TripProperties>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TripProperties> _parser = new pb::MessageParser<TripProperties>(() => new TripProperties());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<TripProperties> _extensions;
        private pb::ExtensionSet<TripProperties> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TripProperties> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TripUpdate.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripProperties() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripProperties(TripProperties other) : this() {
          tripId_ = other.tripId_;
          startDate_ = other.startDate_;
          startTime_ = other.startTime_;
          shapeId_ = other.shapeId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TripProperties Clone() {
          return new TripProperties(this);
        }

        /// <summary>Field number for the "trip_id" field.</summary>
        public const int TripIdFieldNumber = 1;
        private readonly static string TripIdDefaultValue = "";

        private string tripId_;
        /// <summary>
        /// Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
        /// but will start at a different service date and/or time (defined using the TripProperties.start_date and
        /// TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
        /// than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
        /// be populated and will be ignored by consumers.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string TripId {
          get { return tripId_ ?? TripIdDefaultValue; }
          set {
            tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "trip_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasTripId {
          get { return tripId_ != null; }
        }
        /// <summary>Clears the value of the "trip_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTripId() {
          tripId_ = null;
        }

        /// <summary>Field number for the "start_date" field.</summary>
        public const int StartDateFieldNumber = 2;
        private readonly static string StartDateDefaultValue = "";

        private string startDate_;
        /// <summary>
        /// Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
        /// schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StartDate {
          get { return startDate_ ?? StartDateDefaultValue; }
          set {
            startDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "start_date" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStartDate {
          get { return startDate_ != null; }
        }
        /// <summary>Clears the value of the "start_date" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStartDate() {
          startDate_ = null;
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 3;
        private readonly static string StartTimeDefaultValue = "";

        private string startTime_;
        /// <summary>
        /// Defines the departure start time of the trip when its duplicated. See definition of stop_times.departure_time
        /// in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
        /// between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
        /// departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
        /// of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
        /// delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
        /// departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
        /// prediction time values do not have any offset applied to them and indicate the predicted time as provided.
        /// For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
        /// is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
        /// populated and will be ignored by consumers.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string StartTime {
          get { return startTime_ ?? StartTimeDefaultValue; }
          set {
            startTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "start_time" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStartTime {
          get { return startTime_ != null; }
        }
        /// <summary>Clears the value of the "start_time" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStartTime() {
          startTime_ = null;
        }

        /// <summary>Field number for the "shape_id" field.</summary>
        public const int ShapeIdFieldNumber = 4;
        private readonly static string ShapeIdDefaultValue = "";

        private string shapeId_;
        /// <summary>
        /// Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
        /// (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
        /// paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
        /// nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
        /// or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
        /// (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
        /// be marked as schedule_relationship=SKIPPED.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ShapeId {
          get { return shapeId_ ?? ShapeIdDefaultValue; }
          set {
            shapeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "shape_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasShapeId {
          get { return shapeId_ != null; }
        }
        /// <summary>Clears the value of the "shape_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearShapeId() {
          shapeId_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TripProperties);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TripProperties other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TripId != other.TripId) return false;
          if (StartDate != other.StartDate) return false;
          if (StartTime != other.StartTime) return false;
          if (ShapeId != other.ShapeId) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTripId) hash ^= TripId.GetHashCode();
          if (HasStartDate) hash ^= StartDate.GetHashCode();
          if (HasStartTime) hash ^= StartTime.GetHashCode();
          if (HasShapeId) hash ^= ShapeId.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasTripId) {
            output.WriteRawTag(10);
            output.WriteString(TripId);
          }
          if (HasStartDate) {
            output.WriteRawTag(18);
            output.WriteString(StartDate);
          }
          if (HasStartTime) {
            output.WriteRawTag(26);
            output.WriteString(StartTime);
          }
          if (HasShapeId) {
            output.WriteRawTag(34);
            output.WriteString(ShapeId);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTripId) {
            output.WriteRawTag(10);
            output.WriteString(TripId);
          }
          if (HasStartDate) {
            output.WriteRawTag(18);
            output.WriteString(StartDate);
          }
          if (HasStartTime) {
            output.WriteRawTag(26);
            output.WriteString(StartTime);
          }
          if (HasShapeId) {
            output.WriteRawTag(34);
            output.WriteString(ShapeId);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasTripId) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
          }
          if (HasStartDate) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(StartDate);
          }
          if (HasStartTime) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(StartTime);
          }
          if (HasShapeId) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ShapeId);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TripProperties other) {
          if (other == null) {
            return;
          }
          if (other.HasTripId) {
            TripId = other.TripId;
          }
          if (other.HasStartDate) {
            StartDate = other.StartDate;
          }
          if (other.HasStartTime) {
            StartTime = other.StartTime;
          }
          if (other.HasShapeId) {
            ShapeId = other.ShapeId;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 10: {
                TripId = input.ReadString();
                break;
              }
              case 18: {
                StartDate = input.ReadString();
                break;
              }
              case 26: {
                StartTime = input.ReadString();
                break;
              }
              case 34: {
                ShapeId = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 10: {
                TripId = input.ReadString();
                break;
              }
              case 18: {
                StartDate = input.ReadString();
                break;
              }
              case 26: {
                StartTime = input.ReadString();
                break;
              }
              case 34: {
                ShapeId = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<TripProperties, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TripProperties, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TripProperties, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<TripProperties, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<TripProperties, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<TripProperties, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<TripProperties, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Realtime positioning information for a given vehicle.
  /// </summary>
  public sealed partial class VehiclePosition : pb::IExtendableMessage<VehiclePosition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehiclePosition> _parser = new pb::MessageParser<VehiclePosition>(() => new VehiclePosition());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<VehiclePosition> _extensions;
    private pb::ExtensionSet<VehiclePosition> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VehiclePosition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehiclePosition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehiclePosition(VehiclePosition other) : this() {
      _hasBits0 = other._hasBits0;
      trip_ = other.trip_ != null ? other.trip_.Clone() : null;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      position_ = other.position_ != null ? other.position_.Clone() : null;
      currentStopSequence_ = other.currentStopSequence_;
      stopId_ = other.stopId_;
      currentStatus_ = other.currentStatus_;
      timestamp_ = other.timestamp_;
      congestionLevel_ = other.congestionLevel_;
      occupancyStatus_ = other.occupancyStatus_;
      occupancyPercentage_ = other.occupancyPercentage_;
      multiCarriageDetails_ = other.multiCarriageDetails_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehiclePosition Clone() {
      return new VehiclePosition(this);
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 1;
    private global::TransitRealtime.TripDescriptor trip_;
    /// <summary>
    /// The Trip that this vehicle is serving.
    /// Can be empty or partial if the vehicle can not be identified with a given
    /// trip instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 8;
    private global::TransitRealtime.VehicleDescriptor vehicle_;
    /// <summary>
    /// Additional information on the vehicle that is serving this trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehicleDescriptor Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 2;
    private global::TransitRealtime.Position position_;
    /// <summary>
    /// Current position of this vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Position Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "current_stop_sequence" field.</summary>
    public const int CurrentStopSequenceFieldNumber = 3;
    private readonly static uint CurrentStopSequenceDefaultValue = 0;

    private uint currentStopSequence_;
    /// <summary>
    /// The stop sequence index of the current stop. The meaning of
    /// current_stop_sequence (i.e., the stop that it refers to) is determined by
    /// current_status.
    /// If current_status is missing IN_TRANSIT_TO is assumed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint CurrentStopSequence {
      get { if ((_hasBits0 & 1) != 0) { return currentStopSequence_; } else { return CurrentStopSequenceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        currentStopSequence_ = value;
      }
    }
    /// <summary>Gets whether the "current_stop_sequence" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCurrentStopSequence {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "current_stop_sequence" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCurrentStopSequence() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 7;
    private readonly static string StopIdDefaultValue = "";

    private string stopId_;
    /// <summary>
    /// Identifies the current stop. The value must be the same as in stops.txt in
    /// the corresponding GTFS feed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopId {
      get { return stopId_ ?? StopIdDefaultValue; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "stop_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStopId {
      get { return stopId_ != null; }
    }
    /// <summary>Clears the value of the "stop_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStopId() {
      stopId_ = null;
    }

    /// <summary>Field number for the "current_status" field.</summary>
    public const int CurrentStatusFieldNumber = 4;
    private readonly static global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus CurrentStatusDefaultValue = global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus.InTransitTo;

    private global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus currentStatus_;
    /// <summary>
    /// The exact status of the vehicle with respect to the current stop.
    /// Ignored if current_stop_sequence is missing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus {
      get { if ((_hasBits0 & 2) != 0) { return currentStatus_; } else { return CurrentStatusDefaultValue; } }
      set {
        _hasBits0 |= 2;
        currentStatus_ = value;
      }
    }
    /// <summary>Gets whether the "current_status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCurrentStatus {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "current_status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCurrentStatus() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 5;
    private readonly static ulong TimestampDefaultValue = 0UL;

    private ulong timestamp_;
    /// <summary>
    /// Moment at which the vehicle's position was measured. In POSIX time
    /// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Timestamp {
      get { if ((_hasBits0 & 4) != 0) { return timestamp_; } else { return TimestampDefaultValue; } }
      set {
        _hasBits0 |= 4;
        timestamp_ = value;
      }
    }
    /// <summary>Gets whether the "timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestamp {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestamp() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "congestion_level" field.</summary>
    public const int CongestionLevelFieldNumber = 6;
    private readonly static global::TransitRealtime.VehiclePosition.Types.CongestionLevel CongestionLevelDefaultValue = global::TransitRealtime.VehiclePosition.Types.CongestionLevel.UnknownCongestionLevel;

    private global::TransitRealtime.VehiclePosition.Types.CongestionLevel congestionLevel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehiclePosition.Types.CongestionLevel CongestionLevel {
      get { if ((_hasBits0 & 8) != 0) { return congestionLevel_; } else { return CongestionLevelDefaultValue; } }
      set {
        _hasBits0 |= 8;
        congestionLevel_ = value;
      }
    }
    /// <summary>Gets whether the "congestion_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCongestionLevel {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "congestion_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCongestionLevel() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "occupancy_status" field.</summary>
    public const int OccupancyStatusFieldNumber = 9;
    private readonly static global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatusDefaultValue = global::TransitRealtime.VehiclePosition.Types.OccupancyStatus.Empty;

    private global::TransitRealtime.VehiclePosition.Types.OccupancyStatus occupancyStatus_;
    /// <summary>
    /// If multi_carriage_status is populated with per-carriage OccupancyStatus,
    /// then this field should describe the entire vehicle with all carriages accepting passengers considered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatus {
      get { if ((_hasBits0 & 16) != 0) { return occupancyStatus_; } else { return OccupancyStatusDefaultValue; } }
      set {
        _hasBits0 |= 16;
        occupancyStatus_ = value;
      }
    }
    /// <summary>Gets whether the "occupancy_status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOccupancyStatus {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "occupancy_status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOccupancyStatus() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "occupancy_percentage" field.</summary>
    public const int OccupancyPercentageFieldNumber = 10;
    private readonly static uint OccupancyPercentageDefaultValue = 0;

    private uint occupancyPercentage_;
    /// <summary>
    /// A percentage value indicating the degree of passenger occupancy in the vehicle.
    /// The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
    /// The value 100 should represent the total maximum occupancy the vehicle was designed for,
    /// including both seated and standing capacity, and current operating regulations allow.
    /// The value may exceed 100 if there are more passengers than the maximum designed capacity.
    /// The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
    /// If multi_carriage_status is populated with per-carriage occupancy_percentage, 
    /// then this field should describe the entire vehicle with all carriages accepting passengers considered.
    /// This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint OccupancyPercentage {
      get { if ((_hasBits0 & 32) != 0) { return occupancyPercentage_; } else { return OccupancyPercentageDefaultValue; } }
      set {
        _hasBits0 |= 32;
        occupancyPercentage_ = value;
      }
    }
    /// <summary>Gets whether the "occupancy_percentage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOccupancyPercentage {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "occupancy_percentage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOccupancyPercentage() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "multi_carriage_details" field.</summary>
    public const int MultiCarriageDetailsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::TransitRealtime.VehiclePosition.Types.CarriageDetails> _repeated_multiCarriageDetails_codec
        = pb::FieldCodec.ForMessage(90, global::TransitRealtime.VehiclePosition.Types.CarriageDetails.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.VehiclePosition.Types.CarriageDetails> multiCarriageDetails_ = new pbc::RepeatedField<global::TransitRealtime.VehiclePosition.Types.CarriageDetails>();
    /// <summary>
    /// Details of the multiple carriages of this given vehicle.
    /// The first occurrence represents the first carriage of the vehicle, 
    /// given the current direction of travel. 
    /// The number of occurrences of the multi_carriage_details 
    /// field represents the number of carriages of the vehicle.
    /// It also includes non boardable carriages, 
    /// like engines, maintenance carriages, etc as they provide valuable 
    /// information to passengers about where to stand on a platform.
    /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.VehiclePosition.Types.CarriageDetails> MultiCarriageDetails {
      get { return multiCarriageDetails_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VehiclePosition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VehiclePosition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Trip, other.Trip)) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (CurrentStopSequence != other.CurrentStopSequence) return false;
      if (StopId != other.StopId) return false;
      if (CurrentStatus != other.CurrentStatus) return false;
      if (Timestamp != other.Timestamp) return false;
      if (CongestionLevel != other.CongestionLevel) return false;
      if (OccupancyStatus != other.OccupancyStatus) return false;
      if (OccupancyPercentage != other.OccupancyPercentage) return false;
      if(!multiCarriageDetails_.Equals(other.multiCarriageDetails_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (position_ != null) hash ^= Position.GetHashCode();
      if (HasCurrentStopSequence) hash ^= CurrentStopSequence.GetHashCode();
      if (HasStopId) hash ^= StopId.GetHashCode();
      if (HasCurrentStatus) hash ^= CurrentStatus.GetHashCode();
      if (HasTimestamp) hash ^= Timestamp.GetHashCode();
      if (HasCongestionLevel) hash ^= CongestionLevel.GetHashCode();
      if (HasOccupancyStatus) hash ^= OccupancyStatus.GetHashCode();
      if (HasOccupancyPercentage) hash ^= OccupancyPercentage.GetHashCode();
      hash ^= multiCarriageDetails_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (HasCurrentStopSequence) {
        output.WriteRawTag(24);
        output.WriteUInt32(CurrentStopSequence);
      }
      if (HasCurrentStatus) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CurrentStatus);
      }
      if (HasTimestamp) {
        output.WriteRawTag(40);
        output.WriteUInt64(Timestamp);
      }
      if (HasCongestionLevel) {
        output.WriteRawTag(48);
        output.WriteEnum((int) CongestionLevel);
      }
      if (HasStopId) {
        output.WriteRawTag(58);
        output.WriteString(StopId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Vehicle);
      }
      if (HasOccupancyStatus) {
        output.WriteRawTag(72);
        output.WriteEnum((int) OccupancyStatus);
      }
      if (HasOccupancyPercentage) {
        output.WriteRawTag(80);
        output.WriteUInt32(OccupancyPercentage);
      }
      multiCarriageDetails_.WriteTo(output, _repeated_multiCarriageDetails_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (trip_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Trip);
      }
      if (position_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Position);
      }
      if (HasCurrentStopSequence) {
        output.WriteRawTag(24);
        output.WriteUInt32(CurrentStopSequence);
      }
      if (HasCurrentStatus) {
        output.WriteRawTag(32);
        output.WriteEnum((int) CurrentStatus);
      }
      if (HasTimestamp) {
        output.WriteRawTag(40);
        output.WriteUInt64(Timestamp);
      }
      if (HasCongestionLevel) {
        output.WriteRawTag(48);
        output.WriteEnum((int) CongestionLevel);
      }
      if (HasStopId) {
        output.WriteRawTag(58);
        output.WriteString(StopId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Vehicle);
      }
      if (HasOccupancyStatus) {
        output.WriteRawTag(72);
        output.WriteEnum((int) OccupancyStatus);
      }
      if (HasOccupancyPercentage) {
        output.WriteRawTag(80);
        output.WriteUInt32(OccupancyPercentage);
      }
      multiCarriageDetails_.WriteTo(ref output, _repeated_multiCarriageDetails_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (position_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (HasCurrentStopSequence) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CurrentStopSequence);
      }
      if (HasStopId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      if (HasCurrentStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CurrentStatus);
      }
      if (HasTimestamp) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (HasCongestionLevel) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CongestionLevel);
      }
      if (HasOccupancyStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OccupancyStatus);
      }
      if (HasOccupancyPercentage) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OccupancyPercentage);
      }
      size += multiCarriageDetails_.CalculateSize(_repeated_multiCarriageDetails_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VehiclePosition other) {
      if (other == null) {
        return;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          Trip = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::TransitRealtime.VehicleDescriptor();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.position_ != null) {
        if (position_ == null) {
          Position = new global::TransitRealtime.Position();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.HasCurrentStopSequence) {
        CurrentStopSequence = other.CurrentStopSequence;
      }
      if (other.HasStopId) {
        StopId = other.StopId;
      }
      if (other.HasCurrentStatus) {
        CurrentStatus = other.CurrentStatus;
      }
      if (other.HasTimestamp) {
        Timestamp = other.Timestamp;
      }
      if (other.HasCongestionLevel) {
        CongestionLevel = other.CongestionLevel;
      }
      if (other.HasOccupancyStatus) {
        OccupancyStatus = other.OccupancyStatus;
      }
      if (other.HasOccupancyPercentage) {
        OccupancyPercentage = other.OccupancyPercentage;
      }
      multiCarriageDetails_.Add(other.multiCarriageDetails_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 18: {
            if (position_ == null) {
              Position = new global::TransitRealtime.Position();
            }
            input.ReadMessage(Position);
            break;
          }
          case 24: {
            CurrentStopSequence = input.ReadUInt32();
            break;
          }
          case 32: {
            CurrentStatus = (global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus) input.ReadEnum();
            break;
          }
          case 40: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 48: {
            CongestionLevel = (global::TransitRealtime.VehiclePosition.Types.CongestionLevel) input.ReadEnum();
            break;
          }
          case 58: {
            StopId = input.ReadString();
            break;
          }
          case 66: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 72: {
            OccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
            break;
          }
          case 80: {
            OccupancyPercentage = input.ReadUInt32();
            break;
          }
          case 90: {
            multiCarriageDetails_.AddEntriesFrom(input, _repeated_multiCarriageDetails_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 18: {
            if (position_ == null) {
              Position = new global::TransitRealtime.Position();
            }
            input.ReadMessage(Position);
            break;
          }
          case 24: {
            CurrentStopSequence = input.ReadUInt32();
            break;
          }
          case 32: {
            CurrentStatus = (global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus) input.ReadEnum();
            break;
          }
          case 40: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 48: {
            CongestionLevel = (global::TransitRealtime.VehiclePosition.Types.CongestionLevel) input.ReadEnum();
            break;
          }
          case 58: {
            StopId = input.ReadString();
            break;
          }
          case 66: {
            if (vehicle_ == null) {
              Vehicle = new global::TransitRealtime.VehicleDescriptor();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 72: {
            OccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
            break;
          }
          case 80: {
            OccupancyPercentage = input.ReadUInt32();
            break;
          }
          case 90: {
            multiCarriageDetails_.AddEntriesFrom(ref input, _repeated_multiCarriageDetails_codec);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<VehiclePosition, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<VehiclePosition, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VehiclePosition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum VehicleStopStatus {
        /// <summary>
        /// The vehicle is just about to arrive at the stop (on a stop
        /// display, the vehicle symbol typically flashes).
        /// </summary>
        [pbr::OriginalName("INCOMING_AT")] IncomingAt = 0,
        /// <summary>
        /// The vehicle is standing at the stop.
        /// </summary>
        [pbr::OriginalName("STOPPED_AT")] StoppedAt = 1,
        /// <summary>
        /// The vehicle has departed and is in transit to the next stop.
        /// </summary>
        [pbr::OriginalName("IN_TRANSIT_TO")] InTransitTo = 2,
      }

      /// <summary>
      /// Congestion level that is affecting this vehicle.
      /// </summary>
      public enum CongestionLevel {
        [pbr::OriginalName("UNKNOWN_CONGESTION_LEVEL")] UnknownCongestionLevel = 0,
        [pbr::OriginalName("RUNNING_SMOOTHLY")] RunningSmoothly = 1,
        [pbr::OriginalName("STOP_AND_GO")] StopAndGo = 2,
        [pbr::OriginalName("CONGESTION")] Congestion = 3,
        /// <summary>
        /// People leaving their cars.
        /// </summary>
        [pbr::OriginalName("SEVERE_CONGESTION")] SevereCongestion = 4,
      }

      /// <summary>
      /// The state of passenger occupancy for the vehicle or carriage.
      /// Individual producers may not publish all OccupancyStatus values. Therefore, consumers
      /// must not assume that the OccupancyStatus values follow a linear scale.
      /// Consumers should represent OccupancyStatus values as the state indicated 
      /// and intended by the producer. Likewise, producers must use OccupancyStatus values that
      /// correspond to actual vehicle occupancy states.
      /// For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
      /// This field is still experimental, and subject to change. It may be formally adopted in the future.
      /// </summary>
      public enum OccupancyStatus {
        /// <summary>
        /// The vehicle or carriage is considered empty by most measures, and has few or no
        /// passengers onboard, but is still accepting passengers.
        /// </summary>
        [pbr::OriginalName("EMPTY")] Empty = 0,
        /// <summary>
        /// The vehicle or carriage has a large number of seats available.
        /// The amount of free seats out of the total seats available to be
        /// considered large enough to fall into this category is determined at the
        /// discretion of the producer.
        /// </summary>
        [pbr::OriginalName("MANY_SEATS_AVAILABLE")] ManySeatsAvailable = 1,
        /// <summary>
        /// The vehicle or carriage has a relatively small number of seats available.
        /// The amount of free seats out of the total seats available to be
        /// considered small enough to fall into this category is determined at the
        /// discretion of the feed producer.
        /// </summary>
        [pbr::OriginalName("FEW_SEATS_AVAILABLE")] FewSeatsAvailable = 2,
        /// <summary>
        /// The vehicle or carriage can currently accommodate only standing passengers.
        /// </summary>
        [pbr::OriginalName("STANDING_ROOM_ONLY")] StandingRoomOnly = 3,
        /// <summary>
        /// The vehicle or carriage can currently accommodate only standing passengers
        /// and has limited space for them.
        /// </summary>
        [pbr::OriginalName("CRUSHED_STANDING_ROOM_ONLY")] CrushedStandingRoomOnly = 4,
        /// <summary>
        /// The vehicle or carriage is considered full by most measures, but may still be
        /// allowing passengers to board.
        /// </summary>
        [pbr::OriginalName("FULL")] Full = 5,
        /// <summary>
        /// The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
        /// </summary>
        [pbr::OriginalName("NOT_ACCEPTING_PASSENGERS")] NotAcceptingPassengers = 6,
        /// <summary>
        /// The vehicle or carriage doesn't have any occupancy data available at that time.
        /// </summary>
        [pbr::OriginalName("NO_DATA_AVAILABLE")] NoDataAvailable = 7,
        /// <summary>
        /// The vehicle or carriage is not boardable and never accepts passengers.
        /// Useful for special vehicles or carriages (engine, maintenance carriage, etc).
        /// </summary>
        [pbr::OriginalName("NOT_BOARDABLE")] NotBoardable = 8,
      }

      /// <summary>
      /// Carriage specific details, used for vehicles composed of several carriages
      /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
      /// </summary>
      public sealed partial class CarriageDetails : pb::IExtendableMessage<CarriageDetails>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CarriageDetails> _parser = new pb::MessageParser<CarriageDetails>(() => new CarriageDetails());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<CarriageDetails> _extensions;
        private pb::ExtensionSet<CarriageDetails> _Extensions { get { return _extensions; } }
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CarriageDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.VehiclePosition.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CarriageDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CarriageDetails(CarriageDetails other) : this() {
          _hasBits0 = other._hasBits0;
          id_ = other.id_;
          label_ = other.label_;
          occupancyStatus_ = other.occupancyStatus_;
          occupancyPercentage_ = other.occupancyPercentage_;
          carriageSequence_ = other.carriageSequence_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CarriageDetails Clone() {
          return new CarriageDetails(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private readonly static string IdDefaultValue = "";

        private string id_;
        /// <summary>
        /// Identification of the carriage. Should be unique per vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Id {
          get { return id_ ?? IdDefaultValue; }
          set {
            id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasId {
          get { return id_ != null; }
        }
        /// <summary>Clears the value of the "id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearId() {
          id_ = null;
        }

        /// <summary>Field number for the "label" field.</summary>
        public const int LabelFieldNumber = 2;
        private readonly static string LabelDefaultValue = "";

        private string label_;
        /// <summary>
        /// User visible label that may be shown to the passenger to help identify
        /// the carriage. Example: "7712", "Car ABC-32", etc...
        /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Label {
          get { return label_ ?? LabelDefaultValue; }
          set {
            label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "label" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLabel {
          get { return label_ != null; }
        }
        /// <summary>Clears the value of the "label" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLabel() {
          label_ = null;
        }

        /// <summary>Field number for the "occupancy_status" field.</summary>
        public const int OccupancyStatusFieldNumber = 3;
        private readonly static global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatusDefaultValue = global::TransitRealtime.VehiclePosition.Types.OccupancyStatus.NoDataAvailable;

        private global::TransitRealtime.VehiclePosition.Types.OccupancyStatus occupancyStatus_;
        /// <summary>
        /// Occupancy status for this given carriage, in this vehicle
        /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatus {
          get { if ((_hasBits0 & 1) != 0) { return occupancyStatus_; } else { return OccupancyStatusDefaultValue; } }
          set {
            _hasBits0 |= 1;
            occupancyStatus_ = value;
          }
        }
        /// <summary>Gets whether the "occupancy_status" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOccupancyStatus {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "occupancy_status" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOccupancyStatus() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "occupancy_percentage" field.</summary>
        public const int OccupancyPercentageFieldNumber = 4;
        private readonly static int OccupancyPercentageDefaultValue = -1;

        private int occupancyPercentage_;
        /// <summary>
        /// Occupancy percentage for this given carriage, in this vehicle.
        /// Follows the same rules as "VehiclePosition.occupancy_percentage"
        /// -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
        /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int OccupancyPercentage {
          get { if ((_hasBits0 & 2) != 0) { return occupancyPercentage_; } else { return OccupancyPercentageDefaultValue; } }
          set {
            _hasBits0 |= 2;
            occupancyPercentage_ = value;
          }
        }
        /// <summary>Gets whether the "occupancy_percentage" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOccupancyPercentage {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "occupancy_percentage" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOccupancyPercentage() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "carriage_sequence" field.</summary>
        public const int CarriageSequenceFieldNumber = 5;
        private readonly static uint CarriageSequenceDefaultValue = 0;

        private uint carriageSequence_;
        /// <summary>
        /// Identifies the order of this carriage with respect to the other
        /// carriages in the vehicle's list of CarriageDetails.
        /// The first carriage in the direction of travel must have a value of 1.
        /// The second value corresponds to the second carriage in the direction
        /// of travel and must have a value of 2, and so forth.
        /// For example, the first carriage in the direction of travel has a value of 1.
        /// If the second carriage in the direction of travel has a value of 3,
        /// consumers will discard data for all carriages (i.e., the multi_carriage_details field).
        /// Carriages without data must be represented with a valid carriage_sequence number and the fields 
        /// without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
        /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint CarriageSequence {
          get { if ((_hasBits0 & 4) != 0) { return carriageSequence_; } else { return CarriageSequenceDefaultValue; } }
          set {
            _hasBits0 |= 4;
            carriageSequence_ = value;
          }
        }
        /// <summary>Gets whether the "carriage_sequence" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCarriageSequence {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "carriage_sequence" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCarriageSequence() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CarriageDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CarriageDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Label != other.Label) return false;
          if (OccupancyStatus != other.OccupancyStatus) return false;
          if (OccupancyPercentage != other.OccupancyPercentage) return false;
          if (CarriageSequence != other.CarriageSequence) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasId) hash ^= Id.GetHashCode();
          if (HasLabel) hash ^= Label.GetHashCode();
          if (HasOccupancyStatus) hash ^= OccupancyStatus.GetHashCode();
          if (HasOccupancyPercentage) hash ^= OccupancyPercentage.GetHashCode();
          if (HasCarriageSequence) hash ^= CarriageSequence.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasId) {
            output.WriteRawTag(10);
            output.WriteString(Id);
          }
          if (HasLabel) {
            output.WriteRawTag(18);
            output.WriteString(Label);
          }
          if (HasOccupancyStatus) {
            output.WriteRawTag(24);
            output.WriteEnum((int) OccupancyStatus);
          }
          if (HasOccupancyPercentage) {
            output.WriteRawTag(32);
            output.WriteInt32(OccupancyPercentage);
          }
          if (HasCarriageSequence) {
            output.WriteRawTag(40);
            output.WriteUInt32(CarriageSequence);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasId) {
            output.WriteRawTag(10);
            output.WriteString(Id);
          }
          if (HasLabel) {
            output.WriteRawTag(18);
            output.WriteString(Label);
          }
          if (HasOccupancyStatus) {
            output.WriteRawTag(24);
            output.WriteEnum((int) OccupancyStatus);
          }
          if (HasOccupancyPercentage) {
            output.WriteRawTag(32);
            output.WriteInt32(OccupancyPercentage);
          }
          if (HasCarriageSequence) {
            output.WriteRawTag(40);
            output.WriteUInt32(CarriageSequence);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasId) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
          }
          if (HasLabel) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
          }
          if (HasOccupancyStatus) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OccupancyStatus);
          }
          if (HasOccupancyPercentage) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(OccupancyPercentage);
          }
          if (HasCarriageSequence) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CarriageSequence);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CarriageDetails other) {
          if (other == null) {
            return;
          }
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasLabel) {
            Label = other.Label;
          }
          if (other.HasOccupancyStatus) {
            OccupancyStatus = other.OccupancyStatus;
          }
          if (other.HasOccupancyPercentage) {
            OccupancyPercentage = other.OccupancyPercentage;
          }
          if (other.HasCarriageSequence) {
            CarriageSequence = other.CarriageSequence;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 10: {
                Id = input.ReadString();
                break;
              }
              case 18: {
                Label = input.ReadString();
                break;
              }
              case 24: {
                OccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
                break;
              }
              case 32: {
                OccupancyPercentage = input.ReadInt32();
                break;
              }
              case 40: {
                CarriageSequence = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 10: {
                Id = input.ReadString();
                break;
              }
              case 18: {
                Label = input.ReadString();
                break;
              }
              case 24: {
                OccupancyStatus = (global::TransitRealtime.VehiclePosition.Types.OccupancyStatus) input.ReadEnum();
                break;
              }
              case 32: {
                OccupancyPercentage = input.ReadInt32();
                break;
              }
              case 40: {
                CarriageSequence = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<CarriageDetails, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<CarriageDetails, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<CarriageDetails, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<CarriageDetails, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<CarriageDetails, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<CarriageDetails, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<CarriageDetails, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// An alert, indicating some sort of incident in the public transit network.
  /// </summary>
  public sealed partial class Alert : pb::IExtendableMessage<Alert>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Alert> _parser = new pb::MessageParser<Alert>(() => new Alert());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Alert> _extensions;
    private pb::ExtensionSet<Alert> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Alert> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Alert() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Alert(Alert other) : this() {
      _hasBits0 = other._hasBits0;
      activePeriod_ = other.activePeriod_.Clone();
      informedEntity_ = other.informedEntity_.Clone();
      cause_ = other.cause_;
      effect_ = other.effect_;
      url_ = other.url_ != null ? other.url_.Clone() : null;
      headerText_ = other.headerText_ != null ? other.headerText_.Clone() : null;
      descriptionText_ = other.descriptionText_ != null ? other.descriptionText_.Clone() : null;
      ttsHeaderText_ = other.ttsHeaderText_ != null ? other.ttsHeaderText_.Clone() : null;
      ttsDescriptionText_ = other.ttsDescriptionText_ != null ? other.ttsDescriptionText_.Clone() : null;
      severityLevel_ = other.severityLevel_;
      image_ = other.image_ != null ? other.image_.Clone() : null;
      imageAlternativeText_ = other.imageAlternativeText_ != null ? other.imageAlternativeText_.Clone() : null;
      causeDetail_ = other.causeDetail_ != null ? other.causeDetail_.Clone() : null;
      effectDetail_ = other.effectDetail_ != null ? other.effectDetail_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Alert Clone() {
      return new Alert(this);
    }

    /// <summary>Field number for the "active_period" field.</summary>
    public const int ActivePeriodFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TransitRealtime.TimeRange> _repeated_activePeriod_codec
        = pb::FieldCodec.ForMessage(10, global::TransitRealtime.TimeRange.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TimeRange> activePeriod_ = new pbc::RepeatedField<global::TransitRealtime.TimeRange>();
    /// <summary>
    /// Time when the alert should be shown to the user. If missing, the
    /// alert will be shown as long as it appears in the feed.
    /// If multiple ranges are given, the alert will be shown during all of them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.TimeRange> ActivePeriod {
      get { return activePeriod_; }
    }

    /// <summary>Field number for the "informed_entity" field.</summary>
    public const int InformedEntityFieldNumber = 5;
    private static readonly pb::FieldCodec<global::TransitRealtime.EntitySelector> _repeated_informedEntity_codec
        = pb::FieldCodec.ForMessage(42, global::TransitRealtime.EntitySelector.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.EntitySelector> informedEntity_ = new pbc::RepeatedField<global::TransitRealtime.EntitySelector>();
    /// <summary>
    /// Entities whose users we should notify of this alert.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.EntitySelector> InformedEntity {
      get { return informedEntity_; }
    }

    /// <summary>Field number for the "cause" field.</summary>
    public const int CauseFieldNumber = 6;
    private readonly static global::TransitRealtime.Alert.Types.Cause CauseDefaultValue = global::TransitRealtime.Alert.Types.Cause.UnknownCause;

    private global::TransitRealtime.Alert.Types.Cause cause_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Alert.Types.Cause Cause {
      get { if ((_hasBits0 & 1) != 0) { return cause_; } else { return CauseDefaultValue; } }
      set {
        _hasBits0 |= 1;
        cause_ = value;
      }
    }
    /// <summary>Gets whether the "cause" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCause {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "cause" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCause() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "effect" field.</summary>
    public const int EffectFieldNumber = 7;
    private readonly static global::TransitRealtime.Alert.Types.Effect EffectDefaultValue = global::TransitRealtime.Alert.Types.Effect.UnknownEffect;

    private global::TransitRealtime.Alert.Types.Effect effect_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Alert.Types.Effect Effect {
      get { if ((_hasBits0 & 2) != 0) { return effect_; } else { return EffectDefaultValue; } }
      set {
        _hasBits0 |= 2;
        effect_ = value;
      }
    }
    /// <summary>Gets whether the "effect" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEffect {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "effect" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEffect() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "url" field.</summary>
    public const int UrlFieldNumber = 8;
    private global::TransitRealtime.TranslatedString url_;
    /// <summary>
    /// The URL which provides additional information about the alert.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString Url {
      get { return url_; }
      set {
        url_ = value;
      }
    }

    /// <summary>Field number for the "header_text" field.</summary>
    public const int HeaderTextFieldNumber = 10;
    private global::TransitRealtime.TranslatedString headerText_;
    /// <summary>
    /// Alert header. Contains a short summary of the alert text as plain-text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString HeaderText {
      get { return headerText_; }
      set {
        headerText_ = value;
      }
    }

    /// <summary>Field number for the "description_text" field.</summary>
    public const int DescriptionTextFieldNumber = 11;
    private global::TransitRealtime.TranslatedString descriptionText_;
    /// <summary>
    /// Full description for the alert as plain-text. The information in the
    /// description should add to the information of the header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString DescriptionText {
      get { return descriptionText_; }
      set {
        descriptionText_ = value;
      }
    }

    /// <summary>Field number for the "tts_header_text" field.</summary>
    public const int TtsHeaderTextFieldNumber = 12;
    private global::TransitRealtime.TranslatedString ttsHeaderText_;
    /// <summary>
    /// Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString TtsHeaderText {
      get { return ttsHeaderText_; }
      set {
        ttsHeaderText_ = value;
      }
    }

    /// <summary>Field number for the "tts_description_text" field.</summary>
    public const int TtsDescriptionTextFieldNumber = 13;
    private global::TransitRealtime.TranslatedString ttsDescriptionText_;
    /// <summary>
    /// Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString TtsDescriptionText {
      get { return ttsDescriptionText_; }
      set {
        ttsDescriptionText_ = value;
      }
    }

    /// <summary>Field number for the "severity_level" field.</summary>
    public const int SeverityLevelFieldNumber = 14;
    private readonly static global::TransitRealtime.Alert.Types.SeverityLevel SeverityLevelDefaultValue = global::TransitRealtime.Alert.Types.SeverityLevel.UnknownSeverity;

    private global::TransitRealtime.Alert.Types.SeverityLevel severityLevel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.Alert.Types.SeverityLevel SeverityLevel {
      get { if ((_hasBits0 & 4) != 0) { return severityLevel_; } else { return SeverityLevelDefaultValue; } }
      set {
        _hasBits0 |= 4;
        severityLevel_ = value;
      }
    }
    /// <summary>Gets whether the "severity_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSeverityLevel {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "severity_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSeverityLevel() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 15;
    private global::TransitRealtime.TranslatedImage image_;
    /// <summary>
    /// TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
    /// The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedImage Image {
      get { return image_; }
      set {
        image_ = value;
      }
    }

    /// <summary>Field number for the "image_alternative_text" field.</summary>
    public const int ImageAlternativeTextFieldNumber = 16;
    private global::TransitRealtime.TranslatedString imageAlternativeText_;
    /// <summary>
    /// Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
    /// or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString ImageAlternativeText {
      get { return imageAlternativeText_; }
      set {
        imageAlternativeText_ = value;
      }
    }

    /// <summary>Field number for the "cause_detail" field.</summary>
    public const int CauseDetailFieldNumber = 17;
    private global::TransitRealtime.TranslatedString causeDetail_;
    /// <summary>
    /// Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString CauseDetail {
      get { return causeDetail_; }
      set {
        causeDetail_ = value;
      }
    }

    /// <summary>Field number for the "effect_detail" field.</summary>
    public const int EffectDetailFieldNumber = 18;
    private global::TransitRealtime.TranslatedString effectDetail_;
    /// <summary>
    /// Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TranslatedString EffectDetail {
      get { return effectDetail_; }
      set {
        effectDetail_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Alert);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Alert other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!activePeriod_.Equals(other.activePeriod_)) return false;
      if(!informedEntity_.Equals(other.informedEntity_)) return false;
      if (Cause != other.Cause) return false;
      if (Effect != other.Effect) return false;
      if (!object.Equals(Url, other.Url)) return false;
      if (!object.Equals(HeaderText, other.HeaderText)) return false;
      if (!object.Equals(DescriptionText, other.DescriptionText)) return false;
      if (!object.Equals(TtsHeaderText, other.TtsHeaderText)) return false;
      if (!object.Equals(TtsDescriptionText, other.TtsDescriptionText)) return false;
      if (SeverityLevel != other.SeverityLevel) return false;
      if (!object.Equals(Image, other.Image)) return false;
      if (!object.Equals(ImageAlternativeText, other.ImageAlternativeText)) return false;
      if (!object.Equals(CauseDetail, other.CauseDetail)) return false;
      if (!object.Equals(EffectDetail, other.EffectDetail)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= activePeriod_.GetHashCode();
      hash ^= informedEntity_.GetHashCode();
      if (HasCause) hash ^= Cause.GetHashCode();
      if (HasEffect) hash ^= Effect.GetHashCode();
      if (url_ != null) hash ^= Url.GetHashCode();
      if (headerText_ != null) hash ^= HeaderText.GetHashCode();
      if (descriptionText_ != null) hash ^= DescriptionText.GetHashCode();
      if (ttsHeaderText_ != null) hash ^= TtsHeaderText.GetHashCode();
      if (ttsDescriptionText_ != null) hash ^= TtsDescriptionText.GetHashCode();
      if (HasSeverityLevel) hash ^= SeverityLevel.GetHashCode();
      if (image_ != null) hash ^= Image.GetHashCode();
      if (imageAlternativeText_ != null) hash ^= ImageAlternativeText.GetHashCode();
      if (causeDetail_ != null) hash ^= CauseDetail.GetHashCode();
      if (effectDetail_ != null) hash ^= EffectDetail.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      activePeriod_.WriteTo(output, _repeated_activePeriod_codec);
      informedEntity_.WriteTo(output, _repeated_informedEntity_codec);
      if (HasCause) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Cause);
      }
      if (HasEffect) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Effect);
      }
      if (url_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Url);
      }
      if (headerText_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HeaderText);
      }
      if (descriptionText_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DescriptionText);
      }
      if (ttsHeaderText_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(TtsHeaderText);
      }
      if (ttsDescriptionText_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(TtsDescriptionText);
      }
      if (HasSeverityLevel) {
        output.WriteRawTag(112);
        output.WriteEnum((int) SeverityLevel);
      }
      if (image_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Image);
      }
      if (imageAlternativeText_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ImageAlternativeText);
      }
      if (causeDetail_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(CauseDetail);
      }
      if (effectDetail_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(EffectDetail);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      activePeriod_.WriteTo(ref output, _repeated_activePeriod_codec);
      informedEntity_.WriteTo(ref output, _repeated_informedEntity_codec);
      if (HasCause) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Cause);
      }
      if (HasEffect) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Effect);
      }
      if (url_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Url);
      }
      if (headerText_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HeaderText);
      }
      if (descriptionText_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(DescriptionText);
      }
      if (ttsHeaderText_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(TtsHeaderText);
      }
      if (ttsDescriptionText_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(TtsDescriptionText);
      }
      if (HasSeverityLevel) {
        output.WriteRawTag(112);
        output.WriteEnum((int) SeverityLevel);
      }
      if (image_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Image);
      }
      if (imageAlternativeText_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ImageAlternativeText);
      }
      if (causeDetail_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(CauseDetail);
      }
      if (effectDetail_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(EffectDetail);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += activePeriod_.CalculateSize(_repeated_activePeriod_codec);
      size += informedEntity_.CalculateSize(_repeated_informedEntity_codec);
      if (HasCause) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Cause);
      }
      if (HasEffect) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Effect);
      }
      if (url_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Url);
      }
      if (headerText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderText);
      }
      if (descriptionText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DescriptionText);
      }
      if (ttsHeaderText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TtsHeaderText);
      }
      if (ttsDescriptionText_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TtsDescriptionText);
      }
      if (HasSeverityLevel) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SeverityLevel);
      }
      if (image_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Image);
      }
      if (imageAlternativeText_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ImageAlternativeText);
      }
      if (causeDetail_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CauseDetail);
      }
      if (effectDetail_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EffectDetail);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Alert other) {
      if (other == null) {
        return;
      }
      activePeriod_.Add(other.activePeriod_);
      informedEntity_.Add(other.informedEntity_);
      if (other.HasCause) {
        Cause = other.Cause;
      }
      if (other.HasEffect) {
        Effect = other.Effect;
      }
      if (other.url_ != null) {
        if (url_ == null) {
          Url = new global::TransitRealtime.TranslatedString();
        }
        Url.MergeFrom(other.Url);
      }
      if (other.headerText_ != null) {
        if (headerText_ == null) {
          HeaderText = new global::TransitRealtime.TranslatedString();
        }
        HeaderText.MergeFrom(other.HeaderText);
      }
      if (other.descriptionText_ != null) {
        if (descriptionText_ == null) {
          DescriptionText = new global::TransitRealtime.TranslatedString();
        }
        DescriptionText.MergeFrom(other.DescriptionText);
      }
      if (other.ttsHeaderText_ != null) {
        if (ttsHeaderText_ == null) {
          TtsHeaderText = new global::TransitRealtime.TranslatedString();
        }
        TtsHeaderText.MergeFrom(other.TtsHeaderText);
      }
      if (other.ttsDescriptionText_ != null) {
        if (ttsDescriptionText_ == null) {
          TtsDescriptionText = new global::TransitRealtime.TranslatedString();
        }
        TtsDescriptionText.MergeFrom(other.TtsDescriptionText);
      }
      if (other.HasSeverityLevel) {
        SeverityLevel = other.SeverityLevel;
      }
      if (other.image_ != null) {
        if (image_ == null) {
          Image = new global::TransitRealtime.TranslatedImage();
        }
        Image.MergeFrom(other.Image);
      }
      if (other.imageAlternativeText_ != null) {
        if (imageAlternativeText_ == null) {
          ImageAlternativeText = new global::TransitRealtime.TranslatedString();
        }
        ImageAlternativeText.MergeFrom(other.ImageAlternativeText);
      }
      if (other.causeDetail_ != null) {
        if (causeDetail_ == null) {
          CauseDetail = new global::TransitRealtime.TranslatedString();
        }
        CauseDetail.MergeFrom(other.CauseDetail);
      }
      if (other.effectDetail_ != null) {
        if (effectDetail_ == null) {
          EffectDetail = new global::TransitRealtime.TranslatedString();
        }
        EffectDetail.MergeFrom(other.EffectDetail);
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            activePeriod_.AddEntriesFrom(input, _repeated_activePeriod_codec);
            break;
          }
          case 42: {
            informedEntity_.AddEntriesFrom(input, _repeated_informedEntity_codec);
            break;
          }
          case 48: {
            Cause = (global::TransitRealtime.Alert.Types.Cause) input.ReadEnum();
            break;
          }
          case 56: {
            Effect = (global::TransitRealtime.Alert.Types.Effect) input.ReadEnum();
            break;
          }
          case 66: {
            if (url_ == null) {
              Url = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(Url);
            break;
          }
          case 82: {
            if (headerText_ == null) {
              HeaderText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(HeaderText);
            break;
          }
          case 90: {
            if (descriptionText_ == null) {
              DescriptionText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(DescriptionText);
            break;
          }
          case 98: {
            if (ttsHeaderText_ == null) {
              TtsHeaderText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(TtsHeaderText);
            break;
          }
          case 106: {
            if (ttsDescriptionText_ == null) {
              TtsDescriptionText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(TtsDescriptionText);
            break;
          }
          case 112: {
            SeverityLevel = (global::TransitRealtime.Alert.Types.SeverityLevel) input.ReadEnum();
            break;
          }
          case 122: {
            if (image_ == null) {
              Image = new global::TransitRealtime.TranslatedImage();
            }
            input.ReadMessage(Image);
            break;
          }
          case 130: {
            if (imageAlternativeText_ == null) {
              ImageAlternativeText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(ImageAlternativeText);
            break;
          }
          case 138: {
            if (causeDetail_ == null) {
              CauseDetail = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(CauseDetail);
            break;
          }
          case 146: {
            if (effectDetail_ == null) {
              EffectDetail = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(EffectDetail);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            activePeriod_.AddEntriesFrom(ref input, _repeated_activePeriod_codec);
            break;
          }
          case 42: {
            informedEntity_.AddEntriesFrom(ref input, _repeated_informedEntity_codec);
            break;
          }
          case 48: {
            Cause = (global::TransitRealtime.Alert.Types.Cause) input.ReadEnum();
            break;
          }
          case 56: {
            Effect = (global::TransitRealtime.Alert.Types.Effect) input.ReadEnum();
            break;
          }
          case 66: {
            if (url_ == null) {
              Url = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(Url);
            break;
          }
          case 82: {
            if (headerText_ == null) {
              HeaderText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(HeaderText);
            break;
          }
          case 90: {
            if (descriptionText_ == null) {
              DescriptionText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(DescriptionText);
            break;
          }
          case 98: {
            if (ttsHeaderText_ == null) {
              TtsHeaderText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(TtsHeaderText);
            break;
          }
          case 106: {
            if (ttsDescriptionText_ == null) {
              TtsDescriptionText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(TtsDescriptionText);
            break;
          }
          case 112: {
            SeverityLevel = (global::TransitRealtime.Alert.Types.SeverityLevel) input.ReadEnum();
            break;
          }
          case 122: {
            if (image_ == null) {
              Image = new global::TransitRealtime.TranslatedImage();
            }
            input.ReadMessage(Image);
            break;
          }
          case 130: {
            if (imageAlternativeText_ == null) {
              ImageAlternativeText = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(ImageAlternativeText);
            break;
          }
          case 138: {
            if (causeDetail_ == null) {
              CauseDetail = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(CauseDetail);
            break;
          }
          case 146: {
            if (effectDetail_ == null) {
              EffectDetail = new global::TransitRealtime.TranslatedString();
            }
            input.ReadMessage(EffectDetail);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<Alert, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Alert, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Alert, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Alert, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Alert, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Alert message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Cause of this alert. If cause_detail is included, then Cause must also be included.
      /// </summary>
      public enum Cause {
        [pbr::OriginalName("UNKNOWN_CAUSE")] UnknownCause = 1,
        /// <summary>
        /// Not machine-representable.
        /// </summary>
        [pbr::OriginalName("OTHER_CAUSE")] OtherCause = 2,
        [pbr::OriginalName("TECHNICAL_PROBLEM")] TechnicalProblem = 3,
        /// <summary>
        /// Public transit agency employees stopped working.
        /// </summary>
        [pbr::OriginalName("STRIKE")] Strike = 4,
        /// <summary>
        /// People are blocking the streets.
        /// </summary>
        [pbr::OriginalName("DEMONSTRATION")] Demonstration = 5,
        [pbr::OriginalName("ACCIDENT")] Accident = 6,
        [pbr::OriginalName("HOLIDAY")] Holiday = 7,
        [pbr::OriginalName("WEATHER")] Weather = 8,
        [pbr::OriginalName("MAINTENANCE")] Maintenance = 9,
        [pbr::OriginalName("CONSTRUCTION")] Construction = 10,
        [pbr::OriginalName("POLICE_ACTIVITY")] PoliceActivity = 11,
        [pbr::OriginalName("MEDICAL_EMERGENCY")] MedicalEmergency = 12,
      }

      /// <summary>
      /// What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
      /// </summary>
      public enum Effect {
        [pbr::OriginalName("NO_SERVICE")] NoService = 1,
        [pbr::OriginalName("REDUCED_SERVICE")] ReducedService = 2,
        /// <summary>
        /// We don't care about INsignificant delays: they are hard to detect, have
        /// little impact on the user, and would clutter the results as they are too
        /// frequent.
        /// </summary>
        [pbr::OriginalName("SIGNIFICANT_DELAYS")] SignificantDelays = 3,
        [pbr::OriginalName("DETOUR")] Detour = 4,
        [pbr::OriginalName("ADDITIONAL_SERVICE")] AdditionalService = 5,
        [pbr::OriginalName("MODIFIED_SERVICE")] ModifiedService = 6,
        [pbr::OriginalName("OTHER_EFFECT")] OtherEffect = 7,
        [pbr::OriginalName("UNKNOWN_EFFECT")] UnknownEffect = 8,
        [pbr::OriginalName("STOP_MOVED")] StopMoved = 9,
        [pbr::OriginalName("NO_EFFECT")] NoEffect = 10,
        [pbr::OriginalName("ACCESSIBILITY_ISSUE")] AccessibilityIssue = 11,
      }

      /// <summary>
      /// Severity of this alert.
      /// </summary>
      public enum SeverityLevel {
        [pbr::OriginalName("UNKNOWN_SEVERITY")] UnknownSeverity = 1,
        [pbr::OriginalName("INFO")] Info = 2,
        [pbr::OriginalName("WARNING")] Warning = 3,
        [pbr::OriginalName("SEVERE")] Severe = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// A time interval. The interval is considered active at time 't' if 't' is
  /// greater than or equal to the start time and less than the end time.
  /// </summary>
  public sealed partial class TimeRange : pb::IExtendableMessage<TimeRange>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TimeRange> _parser = new pb::MessageParser<TimeRange>(() => new TimeRange());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TimeRange> _extensions;
    private pb::ExtensionSet<TimeRange> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TimeRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeRange(TimeRange other) : this() {
      _hasBits0 = other._hasBits0;
      start_ = other.start_;
      end_ = other.end_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeRange Clone() {
      return new TimeRange(this);
    }

    /// <summary>Field number for the "start" field.</summary>
    public const int StartFieldNumber = 1;
    private readonly static ulong StartDefaultValue = 0UL;

    private ulong start_;
    /// <summary>
    /// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    /// 00:00:00 UTC).
    /// If missing, the interval starts at minus infinity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Start {
      get { if ((_hasBits0 & 1) != 0) { return start_; } else { return StartDefaultValue; } }
      set {
        _hasBits0 |= 1;
        start_ = value;
      }
    }
    /// <summary>Gets whether the "start" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStart {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "start" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStart() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "end" field.</summary>
    public const int EndFieldNumber = 2;
    private readonly static ulong EndDefaultValue = 0UL;

    private ulong end_;
    /// <summary>
    /// End time, in POSIX time (i.e., number of seconds since January 1st 1970
    /// 00:00:00 UTC).
    /// If missing, the interval ends at plus infinity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong End {
      get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        end_ = value;
      }
    }
    /// <summary>Gets whether the "end" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "end" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnd() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TimeRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TimeRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Start != other.Start) return false;
      if (End != other.End) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStart) hash ^= Start.GetHashCode();
      if (HasEnd) hash ^= End.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStart) {
        output.WriteRawTag(8);
        output.WriteUInt64(Start);
      }
      if (HasEnd) {
        output.WriteRawTag(16);
        output.WriteUInt64(End);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStart) {
        output.WriteRawTag(8);
        output.WriteUInt64(Start);
      }
      if (HasEnd) {
        output.WriteRawTag(16);
        output.WriteUInt64(End);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasStart) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Start);
      }
      if (HasEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(End);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TimeRange other) {
      if (other == null) {
        return;
      }
      if (other.HasStart) {
        Start = other.Start;
      }
      if (other.HasEnd) {
        End = other.End;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            Start = input.ReadUInt64();
            break;
          }
          case 16: {
            End = input.ReadUInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            Start = input.ReadUInt64();
            break;
          }
          case 16: {
            End = input.ReadUInt64();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TimeRange, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TimeRange, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TimeRange, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TimeRange, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TimeRange, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// A position.
  /// </summary>
  public sealed partial class Position : pb::IExtendableMessage<Position>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Position> _parser = new pb::MessageParser<Position>(() => new Position());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Position> _extensions;
    private pb::ExtensionSet<Position> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Position> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Position() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Position(Position other) : this() {
      _hasBits0 = other._hasBits0;
      latitude_ = other.latitude_;
      longitude_ = other.longitude_;
      bearing_ = other.bearing_;
      odometer_ = other.odometer_;
      speed_ = other.speed_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Position Clone() {
      return new Position(this);
    }

    /// <summary>Field number for the "latitude" field.</summary>
    public const int LatitudeFieldNumber = 1;
    private readonly static float LatitudeDefaultValue = 0F;

    private float latitude_;
    /// <summary>
    /// Degrees North, in the WGS-84 coordinate system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Latitude {
      get { if ((_hasBits0 & 1) != 0) { return latitude_; } else { return LatitudeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        latitude_ = value;
      }
    }
    /// <summary>Gets whether the "latitude" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLatitude {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "latitude" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLatitude() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "longitude" field.</summary>
    public const int LongitudeFieldNumber = 2;
    private readonly static float LongitudeDefaultValue = 0F;

    private float longitude_;
    /// <summary>
    /// Degrees East, in the WGS-84 coordinate system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Longitude {
      get { if ((_hasBits0 & 2) != 0) { return longitude_; } else { return LongitudeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        longitude_ = value;
      }
    }
    /// <summary>Gets whether the "longitude" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLongitude {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "longitude" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLongitude() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "bearing" field.</summary>
    public const int BearingFieldNumber = 3;
    private readonly static float BearingDefaultValue = 0F;

    private float bearing_;
    /// <summary>
    /// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    /// This can be the compass bearing, or the direction towards the next stop
    /// or intermediate location.
    /// This should not be direction deduced from the sequence of previous
    /// positions, which can be computed from previous data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Bearing {
      get { if ((_hasBits0 & 4) != 0) { return bearing_; } else { return BearingDefaultValue; } }
      set {
        _hasBits0 |= 4;
        bearing_ = value;
      }
    }
    /// <summary>Gets whether the "bearing" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBearing {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "bearing" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBearing() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "odometer" field.</summary>
    public const int OdometerFieldNumber = 4;
    private readonly static double OdometerDefaultValue = 0D;

    private double odometer_;
    /// <summary>
    /// Odometer value, in meters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Odometer {
      get { if ((_hasBits0 & 8) != 0) { return odometer_; } else { return OdometerDefaultValue; } }
      set {
        _hasBits0 |= 8;
        odometer_ = value;
      }
    }
    /// <summary>Gets whether the "odometer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOdometer {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "odometer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOdometer() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "speed" field.</summary>
    public const int SpeedFieldNumber = 5;
    private readonly static float SpeedDefaultValue = 0F;

    private float speed_;
    /// <summary>
    /// Momentary speed measured by the vehicle, in meters per second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float Speed {
      get { if ((_hasBits0 & 16) != 0) { return speed_; } else { return SpeedDefaultValue; } }
      set {
        _hasBits0 |= 16;
        speed_ = value;
      }
    }
    /// <summary>Gets whether the "speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSpeed {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSpeed() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Position);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Position other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Latitude, other.Latitude)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Longitude, other.Longitude)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Bearing, other.Bearing)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Odometer, other.Odometer)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Speed, other.Speed)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLatitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Latitude);
      if (HasLongitude) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Longitude);
      if (HasBearing) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Bearing);
      if (HasOdometer) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Odometer);
      if (HasSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Speed);
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasLatitude) {
        output.WriteRawTag(13);
        output.WriteFloat(Latitude);
      }
      if (HasLongitude) {
        output.WriteRawTag(21);
        output.WriteFloat(Longitude);
      }
      if (HasBearing) {
        output.WriteRawTag(29);
        output.WriteFloat(Bearing);
      }
      if (HasOdometer) {
        output.WriteRawTag(33);
        output.WriteDouble(Odometer);
      }
      if (HasSpeed) {
        output.WriteRawTag(45);
        output.WriteFloat(Speed);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasLatitude) {
        output.WriteRawTag(13);
        output.WriteFloat(Latitude);
      }
      if (HasLongitude) {
        output.WriteRawTag(21);
        output.WriteFloat(Longitude);
      }
      if (HasBearing) {
        output.WriteRawTag(29);
        output.WriteFloat(Bearing);
      }
      if (HasOdometer) {
        output.WriteRawTag(33);
        output.WriteDouble(Odometer);
      }
      if (HasSpeed) {
        output.WriteRawTag(45);
        output.WriteFloat(Speed);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasLatitude) {
        size += 1 + 4;
      }
      if (HasLongitude) {
        size += 1 + 4;
      }
      if (HasBearing) {
        size += 1 + 4;
      }
      if (HasOdometer) {
        size += 1 + 8;
      }
      if (HasSpeed) {
        size += 1 + 4;
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Position other) {
      if (other == null) {
        return;
      }
      if (other.HasLatitude) {
        Latitude = other.Latitude;
      }
      if (other.HasLongitude) {
        Longitude = other.Longitude;
      }
      if (other.HasBearing) {
        Bearing = other.Bearing;
      }
      if (other.HasOdometer) {
        Odometer = other.Odometer;
      }
      if (other.HasSpeed) {
        Speed = other.Speed;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 13: {
            Latitude = input.ReadFloat();
            break;
          }
          case 21: {
            Longitude = input.ReadFloat();
            break;
          }
          case 29: {
            Bearing = input.ReadFloat();
            break;
          }
          case 33: {
            Odometer = input.ReadDouble();
            break;
          }
          case 45: {
            Speed = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 13: {
            Latitude = input.ReadFloat();
            break;
          }
          case 21: {
            Longitude = input.ReadFloat();
            break;
          }
          case 29: {
            Bearing = input.ReadFloat();
            break;
          }
          case 33: {
            Odometer = input.ReadDouble();
            break;
          }
          case 45: {
            Speed = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<Position, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Position, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Position, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Position, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Position, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// A descriptor that identifies an instance of a GTFS trip, or all instances of
  /// a trip along a route.
  /// - To specify a single trip instance, the trip_id (and if necessary,
  ///   start_time) is set. If route_id is also set, then it should be same as one
  ///   that the given trip corresponds to.
  /// - To specify all the trips along a given route, only the route_id should be
  ///   set. Note that if the trip_id is not known, then stop sequence ids in
  ///   TripUpdate are not sufficient, and stop_ids must be provided as well. In
  ///   addition, absolute arrival/departure times must be provided.
  /// </summary>
  public sealed partial class TripDescriptor : pb::IExtendableMessage<TripDescriptor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TripDescriptor> _parser = new pb::MessageParser<TripDescriptor>(() => new TripDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TripDescriptor> _extensions;
    private pb::ExtensionSet<TripDescriptor> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TripDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripDescriptor(TripDescriptor other) : this() {
      _hasBits0 = other._hasBits0;
      tripId_ = other.tripId_;
      routeId_ = other.routeId_;
      directionId_ = other.directionId_;
      startTime_ = other.startTime_;
      startDate_ = other.startDate_;
      scheduleRelationship_ = other.scheduleRelationship_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TripDescriptor Clone() {
      return new TripDescriptor(this);
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 1;
    private readonly static string TripIdDefaultValue = "";

    private string tripId_;
    /// <summary>
    /// The trip_id from the GTFS feed that this selector refers to.
    /// For non frequency-based trips, this field is enough to uniquely identify
    /// the trip. For frequency-based trip, start_time and start_date might also be
    /// necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
    /// static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
    /// identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripId {
      get { return tripId_ ?? TripIdDefaultValue; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "trip_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTripId {
      get { return tripId_ != null; }
    }
    /// <summary>Clears the value of the "trip_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTripId() {
      tripId_ = null;
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 5;
    private readonly static string RouteIdDefaultValue = "";

    private string routeId_;
    /// <summary>
    /// The route_id from the GTFS that this selector refers to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteId {
      get { return routeId_ ?? RouteIdDefaultValue; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "route_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRouteId {
      get { return routeId_ != null; }
    }
    /// <summary>Clears the value of the "route_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRouteId() {
      routeId_ = null;
    }

    /// <summary>Field number for the "direction_id" field.</summary>
    public const int DirectionIdFieldNumber = 6;
    private readonly static uint DirectionIdDefaultValue = 0;

    private uint directionId_;
    /// <summary>
    /// The direction_id from the GTFS feed trips.txt file, indicating the
    /// direction of travel for trips this selector refers to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DirectionId {
      get { if ((_hasBits0 & 2) != 0) { return directionId_; } else { return DirectionIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        directionId_ = value;
      }
    }
    /// <summary>Gets whether the "direction_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDirectionId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "direction_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDirectionId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 2;
    private readonly static string StartTimeDefaultValue = "";

    private string startTime_;
    /// <summary>
    /// The initially scheduled start time of this trip instance.
    /// When the trip_id corresponds to a non-frequency-based trip, this field
    /// should either be omitted or be equal to the value in the GTFS feed. When
    /// the trip_id correponds to a frequency-based trip, the start_time must be
    /// specified for trip updates and vehicle positions. If the trip corresponds
    /// to exact_times=1 GTFS record, then start_time must be some multiple
    /// (including zero) of headway_secs later than frequencies.txt start_time for
    /// the corresponding time period. If the trip corresponds to exact_times=0,
    /// then its start_time may be arbitrary, and is initially expected to be the
    /// first departure of the trip. Once established, the start_time of this
    /// frequency-based trip should be considered immutable, even if the first
    /// departure time changes -- that time change may instead be reflected in a
    /// StopTimeUpdate.
    /// Format and semantics of the field is same as that of
    /// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StartTime {
      get { return startTime_ ?? StartTimeDefaultValue; }
      set {
        startTime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "start_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStartTime {
      get { return startTime_ != null; }
    }
    /// <summary>Clears the value of the "start_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStartTime() {
      startTime_ = null;
    }

    /// <summary>Field number for the "start_date" field.</summary>
    public const int StartDateFieldNumber = 3;
    private readonly static string StartDateDefaultValue = "";

    private string startDate_;
    /// <summary>
    /// The scheduled start date of this trip instance.
    /// Must be provided to disambiguate trips that are so late as to collide with
    /// a scheduled trip on a next day. For example, for a train that departs 8:00
    /// and 20:00 every day, and is 12 hours late, there would be two distinct
    /// trips on the same time.
    /// This field can be provided but is not mandatory for schedules in which such
    /// collisions are impossible - for example, a service running on hourly
    /// schedule where a vehicle that is one hour late is not considered to be
    /// related to schedule anymore.
    /// In YYYYMMDD format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StartDate {
      get { return startDate_ ?? StartDateDefaultValue; }
      set {
        startDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "start_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStartDate {
      get { return startDate_ != null; }
    }
    /// <summary>Clears the value of the "start_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStartDate() {
      startDate_ = null;
    }

    /// <summary>Field number for the "schedule_relationship" field.</summary>
    public const int ScheduleRelationshipFieldNumber = 4;
    private readonly static global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationshipDefaultValue = global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship.Scheduled;

    private global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship scheduleRelationship_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship {
      get { if ((_hasBits0 & 1) != 0) { return scheduleRelationship_; } else { return ScheduleRelationshipDefaultValue; } }
      set {
        _hasBits0 |= 1;
        scheduleRelationship_ = value;
      }
    }
    /// <summary>Gets whether the "schedule_relationship" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScheduleRelationship {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "schedule_relationship" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScheduleRelationship() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TripDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TripDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TripId != other.TripId) return false;
      if (RouteId != other.RouteId) return false;
      if (DirectionId != other.DirectionId) return false;
      if (StartTime != other.StartTime) return false;
      if (StartDate != other.StartDate) return false;
      if (ScheduleRelationship != other.ScheduleRelationship) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTripId) hash ^= TripId.GetHashCode();
      if (HasRouteId) hash ^= RouteId.GetHashCode();
      if (HasDirectionId) hash ^= DirectionId.GetHashCode();
      if (HasStartTime) hash ^= StartTime.GetHashCode();
      if (HasStartDate) hash ^= StartDate.GetHashCode();
      if (HasScheduleRelationship) hash ^= ScheduleRelationship.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTripId) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (HasStartTime) {
        output.WriteRawTag(18);
        output.WriteString(StartTime);
      }
      if (HasStartDate) {
        output.WriteRawTag(26);
        output.WriteString(StartDate);
      }
      if (HasScheduleRelationship) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ScheduleRelationship);
      }
      if (HasRouteId) {
        output.WriteRawTag(42);
        output.WriteString(RouteId);
      }
      if (HasDirectionId) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTripId) {
        output.WriteRawTag(10);
        output.WriteString(TripId);
      }
      if (HasStartTime) {
        output.WriteRawTag(18);
        output.WriteString(StartTime);
      }
      if (HasStartDate) {
        output.WriteRawTag(26);
        output.WriteString(StartDate);
      }
      if (HasScheduleRelationship) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ScheduleRelationship);
      }
      if (HasRouteId) {
        output.WriteRawTag(42);
        output.WriteString(RouteId);
      }
      if (HasDirectionId) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTripId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (HasRouteId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (HasDirectionId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DirectionId);
      }
      if (HasStartTime) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StartTime);
      }
      if (HasStartDate) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StartDate);
      }
      if (HasScheduleRelationship) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScheduleRelationship);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TripDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.HasTripId) {
        TripId = other.TripId;
      }
      if (other.HasRouteId) {
        RouteId = other.RouteId;
      }
      if (other.HasDirectionId) {
        DirectionId = other.DirectionId;
      }
      if (other.HasStartTime) {
        StartTime = other.StartTime;
      }
      if (other.HasStartDate) {
        StartDate = other.StartDate;
      }
      if (other.HasScheduleRelationship) {
        ScheduleRelationship = other.ScheduleRelationship;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            StartTime = input.ReadString();
            break;
          }
          case 26: {
            StartDate = input.ReadString();
            break;
          }
          case 32: {
            ScheduleRelationship = (global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) input.ReadEnum();
            break;
          }
          case 42: {
            RouteId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            TripId = input.ReadString();
            break;
          }
          case 18: {
            StartTime = input.ReadString();
            break;
          }
          case 26: {
            StartDate = input.ReadString();
            break;
          }
          case 32: {
            ScheduleRelationship = (global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship) input.ReadEnum();
            break;
          }
          case 42: {
            RouteId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TripDescriptor, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TripDescriptor, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TripDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The relation between this trip and the static schedule. If a trip is done
      /// in accordance with temporary schedule, not reflected in GTFS, then it
      /// shouldn't be marked as SCHEDULED, but likely as ADDED.
      /// </summary>
      public enum ScheduleRelationship {
        /// <summary>
        /// Trip that is running in accordance with its GTFS schedule, or is close
        /// enough to the scheduled trip to be associated with it.
        /// </summary>
        [pbr::OriginalName("SCHEDULED")] Scheduled = 0,
        /// <summary>
        /// An extra trip that was added in addition to a running schedule, for
        /// example, to replace a broken vehicle or to respond to sudden passenger
        /// load.
        /// NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
        /// [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
        /// [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
        /// documentation will be updated when those discussions are finalized.
        /// </summary>
        [pbr::OriginalName("ADDED")] Added = 1,
        /// <summary>
        /// A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
        /// Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
        /// </summary>
        [pbr::OriginalName("UNSCHEDULED")] Unscheduled = 2,
        /// <summary>
        /// A trip that existed in the schedule but was removed.
        /// </summary>
        [pbr::OriginalName("CANCELED")] Canceled = 3,
        /// <summary>
        /// Should not be used - for backwards-compatibility only.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [pbr::OriginalName("REPLACEMENT")] Replacement = 5,
        /// <summary>
        /// An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
        /// respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
        /// and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
        /// date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
        /// (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
        /// identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
        /// TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
        /// TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
        /// empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
        /// the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
        /// must also be set to DUPLICATED.
        /// Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
        /// the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
        /// to transition to the DUPLICATED enumeration.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [pbr::OriginalName("DUPLICATED")] Duplicated = 6,
        /// <summary>
        /// A trip that existed in the schedule but was removed and must not be shown to users.
        /// DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
        /// information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
        /// riders, e.g. a trip that is entirely being replaced by another trip.
        /// This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
        /// If consumers were to show explicit information about the cancellations it would distract from the more important
        /// real-time predictions.
        /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        /// </summary>
        [pbr::OriginalName("DELETED")] Deleted = 7,
      }

    }
    #endregion

  }

  /// <summary>
  /// Identification information for the vehicle performing the trip.
  /// </summary>
  public sealed partial class VehicleDescriptor : pb::IExtendableMessage<VehicleDescriptor>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleDescriptor> _parser = new pb::MessageParser<VehicleDescriptor>(() => new VehicleDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<VehicleDescriptor> _extensions;
    private pb::ExtensionSet<VehicleDescriptor> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VehicleDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleDescriptor(VehicleDescriptor other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      label_ = other.label_;
      licensePlate_ = other.licensePlate_;
      wheelchairAccessible_ = other.wheelchairAccessible_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleDescriptor Clone() {
      return new VehicleDescriptor(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static string IdDefaultValue = "";

    private string id_;
    /// <summary>
    /// Internal system identification of the vehicle. Should be unique per
    /// vehicle, and can be used for tracking the vehicle as it proceeds through
    /// the system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Id {
      get { return id_ ?? IdDefaultValue; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return id_ != null; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      id_ = null;
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 2;
    private readonly static string LabelDefaultValue = "";

    private string label_;
    /// <summary>
    /// User visible label, i.e., something that must be shown to the passenger to
    /// help identify the correct vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_ ?? LabelDefaultValue; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "label" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLabel {
      get { return label_ != null; }
    }
    /// <summary>Clears the value of the "label" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLabel() {
      label_ = null;
    }

    /// <summary>Field number for the "license_plate" field.</summary>
    public const int LicensePlateFieldNumber = 3;
    private readonly static string LicensePlateDefaultValue = "";

    private string licensePlate_;
    /// <summary>
    /// The license plate of the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LicensePlate {
      get { return licensePlate_ ?? LicensePlateDefaultValue; }
      set {
        licensePlate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "license_plate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLicensePlate {
      get { return licensePlate_ != null; }
    }
    /// <summary>Clears the value of the "license_plate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLicensePlate() {
      licensePlate_ = null;
    }

    /// <summary>Field number for the "wheelchair_accessible" field.</summary>
    public const int WheelchairAccessibleFieldNumber = 4;
    private readonly static global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible WheelchairAccessibleDefaultValue = global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible.NoValue;

    private global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible wheelchairAccessible_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible WheelchairAccessible {
      get { if ((_hasBits0 & 1) != 0) { return wheelchairAccessible_; } else { return WheelchairAccessibleDefaultValue; } }
      set {
        _hasBits0 |= 1;
        wheelchairAccessible_ = value;
      }
    }
    /// <summary>Gets whether the "wheelchair_accessible" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWheelchairAccessible {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "wheelchair_accessible" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWheelchairAccessible() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VehicleDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VehicleDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Label != other.Label) return false;
      if (LicensePlate != other.LicensePlate) return false;
      if (WheelchairAccessible != other.WheelchairAccessible) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasLabel) hash ^= Label.GetHashCode();
      if (HasLicensePlate) hash ^= LicensePlate.GetHashCode();
      if (HasWheelchairAccessible) hash ^= WheelchairAccessible.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasLabel) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      if (HasLicensePlate) {
        output.WriteRawTag(26);
        output.WriteString(LicensePlate);
      }
      if (HasWheelchairAccessible) {
        output.WriteRawTag(32);
        output.WriteEnum((int) WheelchairAccessible);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (HasLabel) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      if (HasLicensePlate) {
        output.WriteRawTag(26);
        output.WriteString(LicensePlate);
      }
      if (HasWheelchairAccessible) {
        output.WriteRawTag(32);
        output.WriteEnum((int) WheelchairAccessible);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (HasLabel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      if (HasLicensePlate) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LicensePlate);
      }
      if (HasWheelchairAccessible) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WheelchairAccessible);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VehicleDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasLabel) {
        Label = other.Label;
      }
      if (other.HasLicensePlate) {
        LicensePlate = other.LicensePlate;
      }
      if (other.HasWheelchairAccessible) {
        WheelchairAccessible = other.WheelchairAccessible;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            LicensePlate = input.ReadString();
            break;
          }
          case 32: {
            WheelchairAccessible = (global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            LicensePlate = input.ReadString();
            break;
          }
          case 32: {
            WheelchairAccessible = (global::TransitRealtime.VehicleDescriptor.Types.WheelchairAccessible) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<VehicleDescriptor, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<VehicleDescriptor, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VehicleDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum WheelchairAccessible {
        /// <summary>
        /// The trip doesn't have information about wheelchair accessibility.
        /// This is the **default** behavior. If the static GTFS contains a
        /// _wheelchair_accessible_ value, it won't be overwritten.
        /// </summary>
        [pbr::OriginalName("NO_VALUE")] NoValue = 0,
        /// <summary>
        /// The trip has no accessibility value present.
        /// This value will overwrite the value from the GTFS.
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 1,
        /// <summary>
        /// The trip is wheelchair accessible.
        /// This value will overwrite the value from the GTFS.
        /// </summary>
        [pbr::OriginalName("WHEELCHAIR_ACCESSIBLE")] WheelchairAccessible = 2,
        /// <summary>
        /// The trip is **not** wheelchair accessible.
        /// This value will overwrite the value from the GTFS.
        /// </summary>
        [pbr::OriginalName("WHEELCHAIR_INACCESSIBLE")] WheelchairInaccessible = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// A selector for an entity in a GTFS feed.
  /// </summary>
  public sealed partial class EntitySelector : pb::IExtendableMessage<EntitySelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EntitySelector> _parser = new pb::MessageParser<EntitySelector>(() => new EntitySelector());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<EntitySelector> _extensions;
    private pb::ExtensionSet<EntitySelector> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EntitySelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitySelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitySelector(EntitySelector other) : this() {
      _hasBits0 = other._hasBits0;
      agencyId_ = other.agencyId_;
      routeId_ = other.routeId_;
      routeType_ = other.routeType_;
      trip_ = other.trip_ != null ? other.trip_.Clone() : null;
      stopId_ = other.stopId_;
      directionId_ = other.directionId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EntitySelector Clone() {
      return new EntitySelector(this);
    }

    /// <summary>Field number for the "agency_id" field.</summary>
    public const int AgencyIdFieldNumber = 1;
    private readonly static string AgencyIdDefaultValue = "";

    private string agencyId_;
    /// <summary>
    /// The values of the fields should correspond to the appropriate fields in the
    /// GTFS feed.
    /// At least one specifier must be given. If several are given, then the
    /// matching has to apply to all the given specifiers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AgencyId {
      get { return agencyId_ ?? AgencyIdDefaultValue; }
      set {
        agencyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "agency_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAgencyId {
      get { return agencyId_ != null; }
    }
    /// <summary>Clears the value of the "agency_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAgencyId() {
      agencyId_ = null;
    }

    /// <summary>Field number for the "route_id" field.</summary>
    public const int RouteIdFieldNumber = 2;
    private readonly static string RouteIdDefaultValue = "";

    private string routeId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteId {
      get { return routeId_ ?? RouteIdDefaultValue; }
      set {
        routeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "route_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRouteId {
      get { return routeId_ != null; }
    }
    /// <summary>Clears the value of the "route_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRouteId() {
      routeId_ = null;
    }

    /// <summary>Field number for the "route_type" field.</summary>
    public const int RouteTypeFieldNumber = 3;
    private readonly static int RouteTypeDefaultValue = 0;

    private int routeType_;
    /// <summary>
    /// corresponds to route_type in GTFS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RouteType {
      get { if ((_hasBits0 & 1) != 0) { return routeType_; } else { return RouteTypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        routeType_ = value;
      }
    }
    /// <summary>Gets whether the "route_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRouteType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "route_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRouteType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "trip" field.</summary>
    public const int TripFieldNumber = 4;
    private global::TransitRealtime.TripDescriptor trip_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::TransitRealtime.TripDescriptor Trip {
      get { return trip_; }
      set {
        trip_ = value;
      }
    }

    /// <summary>Field number for the "stop_id" field.</summary>
    public const int StopIdFieldNumber = 5;
    private readonly static string StopIdDefaultValue = "";

    private string stopId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StopId {
      get { return stopId_ ?? StopIdDefaultValue; }
      set {
        stopId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "stop_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStopId {
      get { return stopId_ != null; }
    }
    /// <summary>Clears the value of the "stop_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStopId() {
      stopId_ = null;
    }

    /// <summary>Field number for the "direction_id" field.</summary>
    public const int DirectionIdFieldNumber = 6;
    private readonly static uint DirectionIdDefaultValue = 0;

    private uint directionId_;
    /// <summary>
    /// Corresponds to trip direction_id in GTFS trips.txt. If provided the
    /// route_id must also be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DirectionId {
      get { if ((_hasBits0 & 2) != 0) { return directionId_; } else { return DirectionIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        directionId_ = value;
      }
    }
    /// <summary>Gets whether the "direction_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDirectionId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "direction_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDirectionId() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EntitySelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EntitySelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AgencyId != other.AgencyId) return false;
      if (RouteId != other.RouteId) return false;
      if (RouteType != other.RouteType) return false;
      if (!object.Equals(Trip, other.Trip)) return false;
      if (StopId != other.StopId) return false;
      if (DirectionId != other.DirectionId) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAgencyId) hash ^= AgencyId.GetHashCode();
      if (HasRouteId) hash ^= RouteId.GetHashCode();
      if (HasRouteType) hash ^= RouteType.GetHashCode();
      if (trip_ != null) hash ^= Trip.GetHashCode();
      if (HasStopId) hash ^= StopId.GetHashCode();
      if (HasDirectionId) hash ^= DirectionId.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAgencyId) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (HasRouteId) {
        output.WriteRawTag(18);
        output.WriteString(RouteId);
      }
      if (HasRouteType) {
        output.WriteRawTag(24);
        output.WriteInt32(RouteType);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (HasStopId) {
        output.WriteRawTag(42);
        output.WriteString(StopId);
      }
      if (HasDirectionId) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAgencyId) {
        output.WriteRawTag(10);
        output.WriteString(AgencyId);
      }
      if (HasRouteId) {
        output.WriteRawTag(18);
        output.WriteString(RouteId);
      }
      if (HasRouteType) {
        output.WriteRawTag(24);
        output.WriteInt32(RouteType);
      }
      if (trip_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Trip);
      }
      if (HasStopId) {
        output.WriteRawTag(42);
        output.WriteString(StopId);
      }
      if (HasDirectionId) {
        output.WriteRawTag(48);
        output.WriteUInt32(DirectionId);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAgencyId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AgencyId);
      }
      if (HasRouteId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteId);
      }
      if (HasRouteType) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RouteType);
      }
      if (trip_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trip);
      }
      if (HasStopId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopId);
      }
      if (HasDirectionId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DirectionId);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EntitySelector other) {
      if (other == null) {
        return;
      }
      if (other.HasAgencyId) {
        AgencyId = other.AgencyId;
      }
      if (other.HasRouteId) {
        RouteId = other.RouteId;
      }
      if (other.HasRouteType) {
        RouteType = other.RouteType;
      }
      if (other.trip_ != null) {
        if (trip_ == null) {
          Trip = new global::TransitRealtime.TripDescriptor();
        }
        Trip.MergeFrom(other.Trip);
      }
      if (other.HasStopId) {
        StopId = other.StopId;
      }
      if (other.HasDirectionId) {
        DirectionId = other.DirectionId;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            RouteId = input.ReadString();
            break;
          }
          case 24: {
            RouteType = input.ReadInt32();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            StopId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            AgencyId = input.ReadString();
            break;
          }
          case 18: {
            RouteId = input.ReadString();
            break;
          }
          case 24: {
            RouteType = input.ReadInt32();
            break;
          }
          case 34: {
            if (trip_ == null) {
              Trip = new global::TransitRealtime.TripDescriptor();
            }
            input.ReadMessage(Trip);
            break;
          }
          case 42: {
            StopId = input.ReadString();
            break;
          }
          case 48: {
            DirectionId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<EntitySelector, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<EntitySelector, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<EntitySelector, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<EntitySelector, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<EntitySelector, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// An internationalized message containing per-language versions of a snippet of
  /// text or a URL.
  /// One of the strings from a message will be picked up. The resolution proceeds
  /// as follows:
  /// 1. If the UI language matches the language code of a translation,
  ///    the first matching translation is picked.
  /// 2. If a default UI language (e.g., English) matches the language code of a
  ///    translation, the first matching translation is picked.
  /// 3. If some translation has an unspecified language code, that translation is
  ///    picked.
  /// </summary>
  public sealed partial class TranslatedString : pb::IExtendableMessage<TranslatedString>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TranslatedString> _parser = new pb::MessageParser<TranslatedString>(() => new TranslatedString());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TranslatedString> _extensions;
    private pb::ExtensionSet<TranslatedString> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TranslatedString> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedString() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedString(TranslatedString other) : this() {
      translation_ = other.translation_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedString Clone() {
      return new TranslatedString(this);
    }

    /// <summary>Field number for the "translation" field.</summary>
    public const int TranslationFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TransitRealtime.TranslatedString.Types.Translation> _repeated_translation_codec
        = pb::FieldCodec.ForMessage(10, global::TransitRealtime.TranslatedString.Types.Translation.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation> translation_ = new pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation>();
    /// <summary>
    /// At least one translation must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.TranslatedString.Types.Translation> Translation {
      get { return translation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TranslatedString);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TranslatedString other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!translation_.Equals(other.translation_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= translation_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      translation_.WriteTo(output, _repeated_translation_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      translation_.WriteTo(ref output, _repeated_translation_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += translation_.CalculateSize(_repeated_translation_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TranslatedString other) {
      if (other == null) {
        return;
      }
      translation_.Add(other.translation_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            translation_.AddEntriesFrom(input, _repeated_translation_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            translation_.AddEntriesFrom(ref input, _repeated_translation_codec);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TranslatedString, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TranslatedString, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TranslatedString, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TranslatedString, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TranslatedString, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TranslatedString message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Translation : pb::IExtendableMessage<Translation>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Translation> _parser = new pb::MessageParser<Translation>(() => new Translation());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<Translation> _extensions;
        private pb::ExtensionSet<Translation> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Translation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TranslatedString.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Translation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Translation(Translation other) : this() {
          text_ = other.text_;
          language_ = other.language_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Translation Clone() {
          return new Translation(this);
        }

        /// <summary>Field number for the "text" field.</summary>
        public const int TextFieldNumber = 1;
        private readonly static string TextDefaultValue = "";

        private string text_;
        /// <summary>
        /// A UTF-8 string containing the message.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Text {
          get { return text_ ?? TextDefaultValue; }
          set {
            text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "text" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasText {
          get { return text_ != null; }
        }
        /// <summary>Clears the value of the "text" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearText() {
          text_ = null;
        }

        /// <summary>Field number for the "language" field.</summary>
        public const int LanguageFieldNumber = 2;
        private readonly static string LanguageDefaultValue = "";

        private string language_;
        /// <summary>
        /// BCP-47 language code. Can be omitted if the language is unknown or if
        /// no i18n is done at all for the feed. At most one translation is
        /// allowed to have an unspecified language tag.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Language {
          get { return language_ ?? LanguageDefaultValue; }
          set {
            language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "language" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLanguage {
          get { return language_ != null; }
        }
        /// <summary>Clears the value of the "language" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLanguage() {
          language_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Translation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Translation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Text != other.Text) return false;
          if (Language != other.Language) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasText) hash ^= Text.GetHashCode();
          if (HasLanguage) hash ^= Language.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasText) {
            output.WriteRawTag(10);
            output.WriteString(Text);
          }
          if (HasLanguage) {
            output.WriteRawTag(18);
            output.WriteString(Language);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasText) {
            output.WriteRawTag(10);
            output.WriteString(Text);
          }
          if (HasLanguage) {
            output.WriteRawTag(18);
            output.WriteString(Language);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasText) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
          }
          if (HasLanguage) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Translation other) {
          if (other == null) {
            return;
          }
          if (other.HasText) {
            Text = other.Text;
          }
          if (other.HasLanguage) {
            Language = other.Language;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 10: {
                Text = input.ReadString();
                break;
              }
              case 18: {
                Language = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 10: {
                Text = input.ReadString();
                break;
              }
              case 18: {
                Language = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<Translation, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<Translation, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<Translation, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<Translation, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<Translation, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// An internationalized image containing per-language versions of a URL linking to an image
  /// along with meta information
  /// Only one of the images from a message will be retained by consumers. The resolution proceeds
  /// as follows:
  /// 1. If the UI language matches the language code of a translation,
  ///    the first matching translation is picked.
  /// 2. If a default UI language (e.g., English) matches the language code of a
  ///    translation, the first matching translation is picked.
  /// 3. If some translation has an unspecified language code, that translation is
  ///    picked.
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  /// </summary>
  public sealed partial class TranslatedImage : pb::IExtendableMessage<TranslatedImage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TranslatedImage> _parser = new pb::MessageParser<TranslatedImage>(() => new TranslatedImage());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<TranslatedImage> _extensions;
    private pb::ExtensionSet<TranslatedImage> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TranslatedImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedImage(TranslatedImage other) : this() {
      localizedImage_ = other.localizedImage_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TranslatedImage Clone() {
      return new TranslatedImage(this);
    }

    /// <summary>Field number for the "localized_image" field.</summary>
    public const int LocalizedImageFieldNumber = 1;
    private static readonly pb::FieldCodec<global::TransitRealtime.TranslatedImage.Types.LocalizedImage> _repeated_localizedImage_codec
        = pb::FieldCodec.ForMessage(10, global::TransitRealtime.TranslatedImage.Types.LocalizedImage.Parser);
    private readonly pbc::RepeatedField<global::TransitRealtime.TranslatedImage.Types.LocalizedImage> localizedImage_ = new pbc::RepeatedField<global::TransitRealtime.TranslatedImage.Types.LocalizedImage>();
    /// <summary>
    /// At least one localized image must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::TransitRealtime.TranslatedImage.Types.LocalizedImage> LocalizedImage {
      get { return localizedImage_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TranslatedImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TranslatedImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!localizedImage_.Equals(other.localizedImage_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= localizedImage_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      localizedImage_.WriteTo(output, _repeated_localizedImage_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      localizedImage_.WriteTo(ref output, _repeated_localizedImage_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += localizedImage_.CalculateSize(_repeated_localizedImage_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TranslatedImage other) {
      if (other == null) {
        return;
      }
      localizedImage_.Add(other.localizedImage_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            localizedImage_.AddEntriesFrom(input, _repeated_localizedImage_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            localizedImage_.AddEntriesFrom(ref input, _repeated_localizedImage_codec);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<TranslatedImage, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<TranslatedImage, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<TranslatedImage, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<TranslatedImage, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<TranslatedImage, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<TranslatedImage, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<TranslatedImage, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TranslatedImage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class LocalizedImage : pb::IExtendableMessage<LocalizedImage>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocalizedImage> _parser = new pb::MessageParser<LocalizedImage>(() => new LocalizedImage());
        private pb::UnknownFieldSet _unknownFields;
        private pb::ExtensionSet<LocalizedImage> _extensions;
        private pb::ExtensionSet<LocalizedImage> _Extensions { get { return _extensions; } }
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocalizedImage> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::TransitRealtime.TranslatedImage.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocalizedImage() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocalizedImage(LocalizedImage other) : this() {
          url_ = other.url_;
          mediaType_ = other.mediaType_;
          language_ = other.language_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
          _extensions = pb::ExtensionSet.Clone(other._extensions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocalizedImage Clone() {
          return new LocalizedImage(this);
        }

        /// <summary>Field number for the "url" field.</summary>
        public const int UrlFieldNumber = 1;
        private readonly static string UrlDefaultValue = "";

        private string url_;
        /// <summary>
        /// String containing an URL linking to an image
        /// The image linked must be less than 2MB. 
        /// If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
        /// The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Url {
          get { return url_ ?? UrlDefaultValue; }
          set {
            url_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "url" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasUrl {
          get { return url_ != null; }
        }
        /// <summary>Clears the value of the "url" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearUrl() {
          url_ = null;
        }

        /// <summary>Field number for the "media_type" field.</summary>
        public const int MediaTypeFieldNumber = 2;
        private readonly static string MediaTypeDefaultValue = "";

        private string mediaType_;
        /// <summary>
        /// IANA media type as to specify the type of image to be displayed. 
        /// The type must start with "image/"
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string MediaType {
          get { return mediaType_ ?? MediaTypeDefaultValue; }
          set {
            mediaType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "media_type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMediaType {
          get { return mediaType_ != null; }
        }
        /// <summary>Clears the value of the "media_type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMediaType() {
          mediaType_ = null;
        }

        /// <summary>Field number for the "language" field.</summary>
        public const int LanguageFieldNumber = 3;
        private readonly static string LanguageDefaultValue = "";

        private string language_;
        /// <summary>
        /// BCP-47 language code. Can be omitted if the language is unknown or if
        /// no i18n is done at all for the feed. At most one translation is
        /// allowed to have an unspecified language tag.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Language {
          get { return language_ ?? LanguageDefaultValue; }
          set {
            language_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "language" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLanguage {
          get { return language_ != null; }
        }
        /// <summary>Clears the value of the "language" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLanguage() {
          language_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocalizedImage);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocalizedImage other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Url != other.Url) return false;
          if (MediaType != other.MediaType) return false;
          if (Language != other.Language) return false;
          if (!Equals(_extensions, other._extensions)) {
            return false;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasUrl) hash ^= Url.GetHashCode();
          if (HasMediaType) hash ^= MediaType.GetHashCode();
          if (HasLanguage) hash ^= Language.GetHashCode();
          if (_extensions != null) {
            hash ^= _extensions.GetHashCode();
          }
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasUrl) {
            output.WriteRawTag(10);
            output.WriteString(Url);
          }
          if (HasMediaType) {
            output.WriteRawTag(18);
            output.WriteString(MediaType);
          }
          if (HasLanguage) {
            output.WriteRawTag(26);
            output.WriteString(Language);
          }
          if (_extensions != null) {
            _extensions.WriteTo(output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasUrl) {
            output.WriteRawTag(10);
            output.WriteString(Url);
          }
          if (HasMediaType) {
            output.WriteRawTag(18);
            output.WriteString(MediaType);
          }
          if (HasLanguage) {
            output.WriteRawTag(26);
            output.WriteString(Language);
          }
          if (_extensions != null) {
            _extensions.WriteTo(ref output);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasUrl) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Url);
          }
          if (HasMediaType) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(MediaType);
          }
          if (HasLanguage) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Language);
          }
          if (_extensions != null) {
            size += _extensions.CalculateSize();
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocalizedImage other) {
          if (other == null) {
            return;
          }
          if (other.HasUrl) {
            Url = other.Url;
          }
          if (other.HasMediaType) {
            MediaType = other.MediaType;
          }
          if (other.HasLanguage) {
            Language = other.Language;
          }
          pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                }
                break;
              case 10: {
                Url = input.ReadString();
                break;
              }
              case 18: {
                MediaType = input.ReadString();
                break;
              }
              case 26: {
                Language = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
                  _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                }
                break;
              case 10: {
                Url = input.ReadString();
                break;
              }
              case 18: {
                MediaType = input.ReadString();
                break;
              }
              case 26: {
                Language = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        public TValue GetExtension<TValue>(pb::Extension<LocalizedImage, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<LocalizedImage, TValue> extension) {
          return pb::ExtensionSet.Get(ref _extensions, extension);
        }
        public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<LocalizedImage, TValue> extension) {
          return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
        }
        public void SetExtension<TValue>(pb::Extension<LocalizedImage, TValue> extension, TValue value) {
          pb::ExtensionSet.Set(ref _extensions, extension, value);
        }
        public bool HasExtension<TValue>(pb::Extension<LocalizedImage, TValue> extension) {
          return pb::ExtensionSet.Has(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::Extension<LocalizedImage, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }
        public void ClearExtension<TValue>(pb::RepeatedExtension<LocalizedImage, TValue> extension) {
          pb::ExtensionSet.Clear(ref _extensions, extension);
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
  /// such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
  /// Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
  /// the location of Stops exactly, but all Stops on a trip should lie within a small distance of
  /// the shape for that trip, i.e. close to straight line segments connecting the shape points
  /// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
  /// </summary>
  public sealed partial class Shape : pb::IExtendableMessage<Shape>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Shape> _parser = new pb::MessageParser<Shape>(() => new Shape());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Shape> _extensions;
    private pb::ExtensionSet<Shape> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Shape> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TransitRealtime.GtfsProtoReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shape() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shape(Shape other) : this() {
      shapeId_ = other.shapeId_;
      encodedPolyline_ = other.encodedPolyline_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shape Clone() {
      return new Shape(this);
    }

    /// <summary>Field number for the "shape_id" field.</summary>
    public const int ShapeIdFieldNumber = 1;
    private readonly static string ShapeIdDefaultValue = "";

    private string shapeId_;
    /// <summary>
    /// Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
    /// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    /// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ShapeId {
      get { return shapeId_ ?? ShapeIdDefaultValue; }
      set {
        shapeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "shape_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShapeId {
      get { return shapeId_ != null; }
    }
    /// <summary>Clears the value of the "shape_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShapeId() {
      shapeId_ = null;
    }

    /// <summary>Field number for the "encoded_polyline" field.</summary>
    public const int EncodedPolylineFieldNumber = 2;
    private readonly static string EncodedPolylineDefaultValue = "";

    private string encodedPolyline_;
    /// <summary>
    /// Encoded polyline representation of the shape. This polyline must contain at least two points.
    /// For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
    /// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    /// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string EncodedPolyline {
      get { return encodedPolyline_ ?? EncodedPolylineDefaultValue; }
      set {
        encodedPolyline_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "encoded_polyline" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEncodedPolyline {
      get { return encodedPolyline_ != null; }
    }
    /// <summary>Clears the value of the "encoded_polyline" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEncodedPolyline() {
      encodedPolyline_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Shape);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Shape other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShapeId != other.ShapeId) return false;
      if (EncodedPolyline != other.EncodedPolyline) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasShapeId) hash ^= ShapeId.GetHashCode();
      if (HasEncodedPolyline) hash ^= EncodedPolyline.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasShapeId) {
        output.WriteRawTag(10);
        output.WriteString(ShapeId);
      }
      if (HasEncodedPolyline) {
        output.WriteRawTag(18);
        output.WriteString(EncodedPolyline);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasShapeId) {
        output.WriteRawTag(10);
        output.WriteString(ShapeId);
      }
      if (HasEncodedPolyline) {
        output.WriteRawTag(18);
        output.WriteString(EncodedPolyline);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasShapeId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShapeId);
      }
      if (HasEncodedPolyline) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EncodedPolyline);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Shape other) {
      if (other == null) {
        return;
      }
      if (other.HasShapeId) {
        ShapeId = other.ShapeId;
      }
      if (other.HasEncodedPolyline) {
        EncodedPolyline = other.EncodedPolyline;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            ShapeId = input.ReadString();
            break;
          }
          case 18: {
            EncodedPolyline = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            ShapeId = input.ReadString();
            break;
          }
          case 18: {
            EncodedPolyline = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<Shape, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Shape, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Shape, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Shape, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Shape, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Shape, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Shape, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  #endregion

}

#endregion Designer generated code
